<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Fiddler 极速上手]]></title>
    <url>%2F2018%2F01%2F14%2Ffiddler-usage%2F</url>
    <content type="text"><![CDATA[概述Fiddler 是一个 http协议 调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出” Fiddler 的数据（指 [cookie] (http://baike.baidu.com/item/cookie/1119) 、html、js、css 等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。 —— 百度百科 你只需要知道它是一个 “调试代理工具” 就 OK 了，Fiddler 的功能相当强大，网上的教程也有一大堆，本文秉承着从零开始快速上手的理念，所以非必要的地方不会讲的太细，文末推荐了一些写的不错的教程以供喜欢研究的同学仔细研究，如果你英文不错的话直达官方文档任何教程都不用看了，包括本篇。 Fiddler UIFiddler 的界面大概就是下面这个样子 Fiddler 配置下载安装后启动 Fiddler 设置成如下状态，期间需要安装证书 FiddlerRoot.cer。 最后在 Fiddler 命令行中输入 start 并回车，确保其处于 Capturing 状态 Android 端代理设置因为 Fiddler 是 PC 与 服务器之间的代理，而我们需要修改 Android 设备请求的数据包，所以让 PC 作为 Android 设备的代理继而通过 Fiddler 代理 PC 我们就可以在 Fiddler 中抓取到 Android 设备的请求数据了。 保证移动设备与 PC 在同一局域网下 获取 PC 的 IP 地址 设置 Android 设备的 WIFI 代理服务器及端口号（这个端口就是 Fiddler 在一直监听的，默认是 8888） 移动端可以在浏览器中访问 127.0.0.1:8888 来安装证书。如果不安装证书的话只能抓取 HTTP 请求 以上步骤没问题的话，随便打开一个网页，应该就能在 Fiddler 中捕获到移动端的请求会话了。 过滤器 （Filters）上面的步骤中，随便打开一个网页，你可能会看见一堆会话，包括一些其他应用的消息推送，状态同步等待后台网络请求也会显示在会话中，这时就需要过滤掉无用的会话，如下设置后就只显示来自 “weatherapi.market.xiaomi.com” 的会话了，多个 Host 使用 “;” 隔开或一行一个。 检查器 （Inspectors）在检查器中可以预览任意一条会话的详细信息（请求体、响应体等） 自动响应器 （AutoResponder）自动响应器可以模拟一个响应，向符合匹配规则的请求返回自定义内容，匹配规则详细介绍看这里 简单使用场景开发中我们可能会经常遇到这种情况，比如测试登录模块，数据解析调试等场景时，需要多次频繁的请求服务器返回各式各样的数据，可能需要不完整的、有错误的返回结果测试应用的健壮性，需要不同的网络环境来模拟户外使用的场景；如果按照常规方式来测的话可能需要后台给一个测试接口，各种数据后台改一下再请求一次测一下，或者直接把数据放到文件里直接读取，而网络环境更是很难模拟；那么有了 Fiddler ，这种调试就轻松多了，下面是一个简单的修改返回数据示例。 这是 Meizu 系统内置的天气软件 下拉刷新一下数据，可以看到 Fiddler 中捕获到的会话及返回的天气数据 保存返回数据 编辑刚刚保存的 Json 数据，这个 Json 编辑工具不错 在自动响应器中添加匹配规则，修改返回数据为刚才我们改过的文件 再次下拉刷新天气信息，就从文本中返回如下数据了 OK 以上差不多就是 Fiddler 的基础用法了，它还有许多更强大的调试功能和使用场景，喜欢研究的同学可以看看： 零基础学习抓包改包Fiddler自动响应AutoResponder正则匹配官方文档官方文档官方文档]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2 创建虚拟主机]]></title>
    <url>%2F2018%2F01%2F08%2Fapache2-to-create-a-virtual-host%2F</url>
    <content type="text"><![CDATA[1、基础概念虚拟主机术语虚拟主机指的是在单一机器上运行多个网站 (例如 company1.example.com 和 company2.example.com) 。 虚拟主机可以“基于 IP”，即每个 IP 一个站点； 或者“基于名称”， 即每个 IP 多个站点。这些站点运行在同一物理服务器上的事实不会明显的透漏给最终用户。 Apache 是第一个支持基于 IP 的虚拟主机的服务器。 Apache 版本 1.1 和更新的版本同时支持基于 IP 和基于名称的虚拟主机。 基于名称的虚拟主机有时候称为基于主机或非 IP 的虚拟主机. 以下解释是在 Apache 中支持虚拟主机的所有详细信息的文档页面列表。 虚拟主机支持的配置 基于名称的虚拟主机 (每个 IP 多个站点) 基于 IP 的虚拟主机 (每个 IP 一个站点) 虚拟主机样例 文件句柄限制 (应用于日志文件太多) 动态配置的大规模虚拟主机 虚拟主机匹配的深入讨论 配置指令 &lt;VirtualHost&gt; ServerName ServerAlias ServerPath 配置 Apache HTTP Server 侦听特定端口和地址 相关模块 相关指令 core &lt;VirtualHost&gt; mpm_common Listen 当httpd启动时，它绑定到本地机器上的一些端口和地址，并等待传入​​的请求。默认情况下，它监听机器上的所有地址。但是，可能需要通知您在特定的端口上进行监听，或者只监听选定的地址或两者的组合。这通常与虚拟主机功能相结合， 虚拟主机功能决定了如何 httpd响应不同的IP地址，主机名和端口。 该Listen 指令告诉服务器仅接受指定端口或地址和端口组合上的传入请求。如果在Listen 指令中仅指定一个端口号，则服务器将侦听所有接口上的给定端口。如果IP地址和端口一样，服务器将监听给定的端口和接口。Listen可以使用多个指令来指定多个地址和端口进行侦听。服务器将响应来自任何列出的地址和端口的请求。 例如，使服务器接收所有地址的 80、8000 端口请求： Listen 80 Listen 8000 使服务器接收指定地址的 80、8000 端口请求： Listen 192.0.2.1:80 Listen 192.0.2.5:8000 用 Listen 指定协议 大多数 Listen 配置不需要可选的第二协议参数。如果未指定，https 协议则是端口 443 的默认值，http 协议为所有其他端口默认值。该协议用于确定哪个模块应该处理请求，以及使用该 AcceptFilter 指令应用协议特定的优化。 如果您在非标准端口上运行，则只需设置协议。例如，使用 https 协议在端口 8443 上运行一个站点： Listen 192.170.2.1:8443 https Listen 与虚拟主机是如何协同工作的 Listen 指令不实现虚拟主机 - 它只告诉主服务器要监听的地址和端口。如果不使用&lt;VirtualHost&gt; 指令，则服务器对于所有接受的请求将以相同的方式处理。但是，&lt;VirtualHost&gt; 可以用来为一个或多个地址或端口指定不同的行为。要实现VirtualHost，服务器必须先被告知要使用的地址和端口。然后&lt;VirtualHost&gt;为指定的地址和端口创建一个配置来设置这个虚拟主机的行为。请注意，如果&lt;VirtualHost&gt;设置为服务器未侦听的地址和端口，则无法访问。 2、配置虚拟主机上传站点到服务器 Apache 站点根目录位于 /var/www/ ，新上传站点应位于 www 目录下，站点目录命名规则推荐使用 domain-port 创建站点目录 $ cd /var/www $ mkdir domain-7777 上传请注意 index.html 应位于 domain-7777 目录 创建虚拟主机配置文件 $ cd /etc/apache2/sites-available/ $ vim 7777-ssl.conf 输入如下配置并保存 Listen 7777 &lt;IfModule mod_ssl.c&gt; &lt;VirtualHost *:7777&gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request&apos;s Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost ServerName rak.example.com DocumentRoot /var/www/domain-7777 # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with &quot;a2disconf&quot;. #Include conf-available/serve-cgi-bin.conf SSLCertificateFile /etc/letsencrypt/live/rak.example.com/cert.pem SSLCertificateKeyFile /etc/letsencrypt/live/rak.example.com/privkey.pem Include /etc/letsencrypt/options-ssl-apache.conf SSLCertificateChainFile /etc/letsencrypt/live/rak.example.com/chain.pem &lt;/VirtualHost&gt; &lt;/IfModule&gt; 使 7777-ssl.conf 配置生效 Apache 配置文件默认放在 -available 后缀的目录下，-enabled 后缀目录下放的是配置文件的引用，而 Apache 服务启动时只会加载 -enabled 后缀目录下的引用；Apache 这么做的目的是为了便于配置文件的管理，比如你要关闭一个虚拟主机，只需删除-enabled 后缀目录下相关虚拟主机的配置引用即可，而不必删除此虚拟主机配置文件本身，需要再次启动此虚拟主机时，只需要再次添加此虚拟主机相应配置文件的引用到 -enabled 后缀目录下即可 所以，这里除了创建 7777-ssl.conf 配置文件，还需要将其引用到 sites-enabled/ 下 $ ln -s /etc/apache2/site-available/7777-ssl.conf /etc/apache2/site-enabled/7777-ssl.conf 使用 a2ensite 命令启动虚拟主机，使用 a2dissite 命令停止虚拟主机 $ a2ensite 7777-ssl.conf $ service apache2 reload 检查端口 7777 是否正常被侦听 $ netstat -a | grep &apos;:7777&apos; 正常状态会查到如下结果 tcp 0 0 *:7777 *:* LISTEN 如果没有结果，请尝试重启 Apache 服务器 $ service apache2 restart 现在，输入 https://rak.example.com:7777 即可访问位于/var/www/domain-7777/下的站点了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 的文件操作]]></title>
    <url>%2F2017%2F11%2F16%2Fgradle-file-operation%2F</url>
    <content type="text"><![CDATA[概述众所周知，Gradle 作为一个项目构建工具，使用了 Groovy 语言来表述其脚本代码，而 Groovy 语言中的很多特性设计的有点“反人类”，这些特性对于老手来说写起来非常舒服，但是对于新手就很不友好了，因为不便于理解，很多萌新看着 Gradle 的脚本感觉很简单很清晰的样子，但是真到了自己去写的时候就会感觉无从下手，怎么写怎么报错；本文就从Gradle 的几个简单的文件操作顺带来分析一下这些奇葩的坑点，让大家对 Groovy 语法特性有个大致认知。 准备一个文件目录如下：点击下载 准确的Tree结构:root│ build.gradle│ solution.gradle│ └──src ├──docs │ aa.aa │ install.md │ install.txt │ readme.txt │ └──web │ index.html │ └──images cat.jpg dog.jpg 任务1) 拷贝src/web目录到build/web目录，并且拷贝src/docs目录下的所有 txt 文件到build/web/help下。2) 打包build/web目录下除 images 文件夹外的所有文件为web.zip，并将web.zip放置于build目录下。3) 解压build/web.zip到build/exploded4) 删除build/web/help 解决方案//1.Copytask copyWeb(type:Copy)&#123; from 'src/web' from ('src/docs')&#123; include '*.txt' into 'help' &#125; into 'build/web'&#125;//2.Ziptask bundleWeb(type:Zip,dependsOn:copyWeb)&#123; baseName 'web' destinationDir file('build') from 'build/web' exclude 'images/**'&#125;//3.UnZiptask unpackBundle(type:Copy,dependsOn:bundleWeb)&#123; from zipTree('build/web.zip') into 'build/exploded'&#125;//4.Deletetask deleteHelp(type:Delete,dependsOn:copyWeb)&#123; delete 'build/web/help'&#125; 是的你没有看错，任务中的4个问题就用上面这20几行代码轻松解决；但是，你可能还是不太清楚这些这些配置的规则，它们看上去就像一堆键值对类似于Json，然而实际上它们都是由属性和方法构成的，就像Java一样： 属性 描述 类型 excludes 排除模式集合 Set includes 包含模式集合 Set baseName 文件的基本名称 String destinationDir 文件生成的目录 File 方法 描述 返回 from(sourcePaths)) 指定副本的源文件或目录 AbstractCopyTask include(includes)) 指定包含模式 AbstractCopyTask exclude(excludes)) 指定排除模式 AbstractCopyTask into(destDir)) 指定副本的目标目录 AbstractCopyTask 所以上面解决方案的完整写法：//1.Copytask copyWeb(type:Copy)&#123; from(&apos;src/web&apos;) from(&apos;src/docs&apos;)&#123; include(&apos;*.txt&apos;) into(&apos;help&apos;) &#125; into(&apos;build/web&apos;)&#125;//2.Ziptask bundleWeb(type:Zip,dependsOn:copyWeb)&#123; baseName=&apos;web&apos; destinationDir=file(&apos;build&apos;) from(&apos;build/web&apos;) exclude(&apos;images/**&apos;)&#125;//3.UnZiptask unpackBundle(type:Copy,dependsOn:bundleWeb)&#123; from(zipTree(&apos;build/web.zip&apos;)) into(&apos;build/exploded&apos;)&#125;//4.Deletetask deleteHelp(type:Delete,dependsOn:copyWeb)&#123; delete(&apos;build/web/help&apos;)&#125; 这样看起来就清晰多了，以上脚本中用到的所有方法及属性都可以在 Gradle DSL Reference 文档中查到，该文档详尽的解释了每个方法及参数的作用，由于 Groovy 语言的特性，一般 Gradle 脚本都会使用简写的方式，也就是省略掉‘()’、‘=’等符号，因为省略掉这些符号不会影响到语法歧义，说到歧义大家可以看到 3.UnZip 中有一行代码 from(zipTree(&#39;build/web.zip&#39;)) 即使简写也只能写成 from zipTree(&#39;build/web.zip&#39;) 而非 from zipTree &#39;build/web.zip&#39;，因为最后这种写法显然使 Groovy 无法理解你要将 &#39;build/web.zip&#39; 作为 zipTree 的参数还是 from 的参数 其实在任何一种计算机语言中各种‘()’、‘[]’、‘{}’都是为了避免产生语法歧义，只要你掌握其中规则，知道怎么写才能避免歧义使代码正常运作，再了解其特有的语言特性如闭包、lambda、委托等，你就大致掌握了这门语言。现在再来看看 Groovy ，它其实就是一种不需要 public修饰符、类型说明、构造函数以及 （）的 Java简化版。]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FloatWindowUtils 实现及事件冲突解决详解]]></title>
    <url>%2F2017%2F05%2F31%2Ffloat-window-utils%2F</url>
    <content type="text"><![CDATA[概述悬浮窗即可以显示在宿主应用之外的 View 视图，理论上任何 View 都能以悬浮窗形式展示在宿主应用之外甚至锁屏界面，一般在工具类应用中使用的比较多，通过悬浮窗可以很方便的从外界与宿主应用进行交互，例如金山词霸的锁屏单词功能、AirDroid 的录制屏幕菜单、360优化大师的清理悬浮按钮等。 需要了解的Window Window 表示一个窗口的概念，在日常开发中直接接触 Window 的机会并不多，但是在特殊时候我们需要在桌面显示一个类似悬浮窗的东西，那么这种效果就需要用到 Window 来实现。Window 是一个抽象类，它的具体实现是 PhoneWindow。创建一个 Window 非常简单，我们通过 WindowManager 即可完成。 Android 中所有视图都是通过 Window 来呈现的，不管是 Activity、Dialog、还是 Toast，它们的视图实际上都是附加在 Window 上的。 WindowManager 应用程序用于与窗口管理器通信的接口，是外界访问 Window 的入口，使用 Context.getSystemService(Context.WINDOW_SERVICE) 获取它的实例。WindowManager提供了 addView(View view, ViewGroup.LayoutParams params)，removeView(View view)，updateViewLayout(View view, ViewGroup.LayoutParams params) 三个方法用来向设备屏幕 添加、移除以及更新 一个 view 。 WindowManager.LayoutParams 通过名字就可以看出来 它是WindowManager的一个内部类，专门用来描述 view 的属性 比如大小、透明度 、初始位置、视图层级等。 DisplayMetrics 该对象用来描述关于显示器的一些信息，例如其大小，密度和字体缩放。例如获取屏幕宽度DisplayMetrics.widthPixels 。 最终效果 实现思路本着实现一个简单的、轻量级的工具类的目的，通过传入一个任意 View 可以将其创建成可自由拖动的悬浮窗 悬浮一个 View 首先我们知道 View 能显示在屏幕上其实是间接通过 Window 管理的，那么我们就可以使用 WindowManager 来管理它，让它具备悬浮的属性，下面代码演示了通过 WindowManager 添加 Window 的过程，非常简单 final Button mBtn = new Button(this);mBtn.setText("悬浮按钮");mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context,"click",Toast.LENGTH_SHORT).show(); &#125;&#125;);final WindowManager.LayoutParams mLayoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT ,WindowManager.LayoutParams.WRAP_CONTENT,0,0, PixelFormat.TRANSPARENT);mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP; //view 处于屏幕的相对位置，注意这里必须是 LEFT &amp; TOP，因为 Android 设备屏幕坐标原点在左上角mLayoutParams.x = 100; //距离屏幕左侧100pxmLayoutParams.y = 300; //距离屏幕上方300pxmLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; //指定 Window 类型为 TYPE_SYSTEM_ALERT，属于系统级别，就可以显示在系统屏幕上了final WindowManager mWindowManager = getWindowManager();mWindowManager.addView(mBtn,mLayoutParams); 别忘了系统级窗口权限 &lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; 效果如下 使其可以拖动 显然上面的 Button 只是能显示在系统屏幕上而已，并不能拖动，要使其能够拖动就要给它设置一个 View.OnTouchListener 来监听手指在屏幕上滑动的坐标然后根据这个坐标设置其位置，如下实现 mBtn.setOnTouchListener(new View.OnTouchListener() &#123; //触摸点相对于view左上角的坐标 float downX; float downY; @Override public boolean onTouch(View v, MotionEvent event) &#123; //获取触摸点相对于屏幕左上角的坐标 float rowX = event.getRawX(); float rowY = event.getRawY() - getStatusBarHeight(context); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = event.getX(); downY = event.getY(); break; case MotionEvent.ACTION_MOVE: mLayoutParams.x = (int) (rowX - downX); //计算当前触摸点相对于屏幕左上角的 X 轴位置 mLayoutParams.y = (int) (rowY - downY); //计算当前触摸点相对于屏幕左上角的 Y 轴位置 mWindowManager.updateViewLayout(mBtn, mLayoutParams); //更新 Button 到相应位置 break; case MotionEvent.ACTION_UP: //actionUp(event); break; case MotionEvent.ACTION_OUTSIDE: //actionOutSide(event); break; default: break; &#125; return false; &#125;&#125;); 解决点击和滑动的事件冲突 现在这个 Button 虽然可以跟着你的手指移动了，但是你会发现当你拖动一段较小距离时会有很大几率响应它的 Click 事件，这显然不能接受，在拖动这个 Button 的整个过程中会依次触发 ACTION_DOWN、ACTION_MOVE、ACTION_MOVE、… 、ACTION_UP，当 ACTION_MOVE 被触发时 ACTION_DOWN 会被释放，之后松开手指触发 ACTION_UP 是不会响应 Click 事件的， Click 事件的响应条件是 ACTION_DOWN + ACTION_UP，所以当我们拖动一个很小的距离时很容易造成 ACTION_DOWN 与 ACTION_UP 的连续触发而响应了 Click 事件，尤其是在 DPI 较高的设备上，下面是一个根据最小偏移量来判断是否应该响应 Click 事件的一种方式 ...//拖动的最小偏移量int MIN_OFFSET = 5;//是否视为 click 事件boolean isClick = false;@Overridepublic boolean onTouch(View v, MotionEvent event) &#123; ... switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: isClick = true; ... break; case MotionEvent.ACTION_MOVE: ... // 通过拖拽的距离是否超过最小偏移量来判断点击事件 if (Math.abs((rowX - downX)) &gt; MIN_OFFSET &amp;&amp; Math.abs((rowY - downY)) &gt; MIN_OFFSET)&#123; isClick = false; &#125;else &#123; isClick = true; &#125; break; case MotionEvent.ACTION_UP: if (isClick)&#123; // 执行点击事件 &#125; break; default: break; &#125; return false;&#125; 最终改进 上述方式固然可以解决冲突问题，但是点击事件被放在 ACTION_UP 之下，或需要整个接口在外面调用很不优雅，下面的解决办法是通过父级 View 进行拦截，也就是将所有传进来的 View 先放入一个 ViewGroup 中，给这个 ViewGroup 设置 View.OnTouchListener，重写这个 ViewGroup 的 onInterceptTouchEvent 方法，根据拖拽的意图让它决定是否拦截所有事件不向下传递，从根本上解决冲突，并且把设置 Window 的属性相关也集成进去，外界只需传入一个 View 即可，下面是 FloatWindowUtils 全部实现过程 public class FloatWindowUtils &#123; private WindowManager.LayoutParams mLayoutParams; private WindowManager mWindowManager; private DisplayMetrics mDisplayMetrics; //view 相对于屏幕触摸点的偏移量(一般仅减去Y轴状态栏高度) int offsetX; int offsetY; //触摸点相对于view左上角的坐标 float downX; float downY; //触摸点相对于屏幕左上角的坐标 float rowX; float rowY; //悬浮窗显示标记 boolean isShowing; //拖动最小偏移量 private static final int MINIMUM_OFFSET = 5; private Context mContext; //是否自动贴边 private boolean autoAlign; //是否模态窗口 private boolean modality; //是否可拖动 private boolean moveAble; //内部定义的View，专门处理事件拦截的父View private FloatView floatView; //外部传进来的需要悬浮的View private View contentView; public FloatWindowUtils(Builder builder) &#123; this.mContext = builder.context; this.autoAlign = builder.autoAlign; this.modality = builder.modality; this.contentView = builder.contentView; this.moveAble = builder.moveAble; initWindowManager(); initLayoutParams(); initFloatView(); &#125; private void initWindowManager() &#123; mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); //获取一个DisplayMetrics对象，该对象用来描述关于显示器的一些信息，例如其大小，密度和字体缩放。 mDisplayMetrics = new DisplayMetrics(); mWindowManager.getDefaultDisplay().getMetrics(mDisplayMetrics); &#125; private void initFloatView() &#123; floatView = new FloatView(mContext); if (moveAble) &#123; floatView.setOnTouchListener(new WindowTouchListener()); &#125; &#125; private void initLayoutParams() &#123; mLayoutParams = new WindowManager.LayoutParams(); mLayoutParams.flags = WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_DIM_BEHIND; if (modality) &#123; mLayoutParams.flags &amp;= ~WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; mLayoutParams.flags &amp;= ~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; &#125; mLayoutParams.height = LinearLayout.LayoutParams.WRAP_CONTENT; mLayoutParams.width = LinearLayout.LayoutParams.WRAP_CONTENT; mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP; mLayoutParams.format = PixelFormat.RGBA_8888; //此处mLayoutParams.type不建议使用TYPE_TOAST，因为在一些三方ROM中会出现拖动异常的问题，虽然它不需要权限 mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; //悬浮窗背景明暗度0~1，数值越大背景越暗，只有在flags设置了WindowManager.LayoutParams.FLAG_DIM_BEHIND 这个属性才会生效 mLayoutParams.dimAmount = 0.0f; //悬浮窗透明度0~1，数值越大越不透明 mLayoutParams.alpha = 0.8f; offsetX = 0; offsetY = getStatusBarHeight(mContext); //设置初始位置 mLayoutParams.x = mDisplayMetrics.widthPixels - offsetX; mLayoutParams.y = mDisplayMetrics.widthPixels*3/4 - offsetY; &#125; /** * 将窗体添加到屏幕上 */ public void show() &#123; if (!isAppOps(mContext))&#123;// openOpsSettings(mContext);// Toast.makeText(mContext,"需要授权应用悬浮权限",Toast.LENGTH_SHORT).show(); return; &#125; if (!isShowing()) &#123; mWindowManager.addView(floatView, mLayoutParams); isShowing = true; &#125; &#125; /** * 悬浮窗是否正在显示 * * @return true if it's showing. */ private boolean isShowing() &#123; if (floatView != null &amp;&amp; floatView.getVisibility() == View.VISIBLE) &#123; return isShowing; &#125; return false; &#125; /** * 打开悬浮窗设置页 * 部分第三方ROM无法直接跳转可使用&#123;@link #openAppSettings(Context)&#125;跳到应用详情页 * * @param context * @return true if it's open successful. */ public static boolean openOpsSettings(Context context)&#123; try &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + context.getPackageName())); context.startActivity(intent); &#125;catch (Exception e)&#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 打开应用详情页 * @param context * @return true if it's open success. */ public static boolean openAppSettings(Context context)&#123; try &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts("package", context.getPackageName(), null); intent.setData(uri); context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 判断 悬浮窗口权限是否打开 * 由于android未提供直接跳转到悬浮窗设置页的api，此方法使用反射去查找相关函数进行跳转 * 部分第三方ROM可能不适用 * @param context * @return true 允许 false禁止 */ public static boolean isAppOps(Context context) &#123; try &#123; Object object = context.getSystemService(Context.APP_OPS_SERVICE); if (object == null) &#123; return false; &#125; Class localClass = object.getClass(); Class[] arrayOfClass = new Class[3]; arrayOfClass[0] = Integer.TYPE; arrayOfClass[1] = Integer.TYPE; arrayOfClass[2] = String.class; Method method = localClass.getMethod("checkOp", arrayOfClass); if (method == null) &#123; return false; &#125; Object[] arrayOfObject1 = new Object[3]; arrayOfObject1[0] = Integer.valueOf(24); arrayOfObject1[1] = Integer.valueOf(Binder.getCallingUid()); arrayOfObject1[2] = context.getPackageName(); int m = ((Integer) method.invoke(object, arrayOfObject1)).intValue(); return m == AppOpsManager.MODE_ALLOWED; &#125; catch (Exception ex) &#123; &#125; return false; &#125; /** * 移除悬浮窗 */ public void remove() &#123; if (isShowing()) &#123; floatView.removeView(contentView); mWindowManager.removeView(floatView); isShowing = false; &#125; &#125; /** * 用于获取系统状态栏的高度。 * * @return 返回状态栏高度的像素值。 */ public static int getStatusBarHeight(Context ctx) &#123; int Identifier = ctx.getResources().getIdentifier("status_bar_height", "dimen", "android"); if (Identifier &gt; 0) &#123; return ctx.getResources().getDimensionPixelSize(Identifier); &#125; return 0; &#125; class FloatView extends LinearLayout&#123; //记录按下位置 int interceptX=0; int interceptY=0; public FloatView(Context context) &#123; super(context); //这里由于一个ViewGroup不能add一个已经有Parent的contentView,所以需要先判断contentView是否有Parent //如果有则需要将contentView先移除 if (contentView.getParent()!=null&amp;&amp;contentView.getParent() instanceof ViewGroup)&#123; ((ViewGroup) contentView.getParent()).removeView(contentView); &#125; addView(contentView); &#125; /** * 解决点击与拖动冲突的关键代码 * @param ev * @return */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //此回调如果返回true则表示拦截TouchEvent由自己处理，false表示不拦截TouchEvent分发出去由子view处理 //解决方案：如果是拖动父View则返回true调用自己的onTouch改变位置，是点击则返回false去响应子view的点击事件 boolean isIntercept = false; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: interceptX = (int) ev.getX(); interceptY = (int) ev.getY(); downX = ev.getX(); downY = ev.getY(); isIntercept = false; break; case MotionEvent.ACTION_MOVE: //在一些dpi较高的设备上点击view很容易触发 ACTION_MOVE，所以此处做一个过滤 if (Math.abs(ev.getX()-interceptX)&gt;MINIMUM_OFFSET&amp;&amp;Math.abs(ev.getY()-interceptY)&gt;MINIMUM_OFFSET)&#123; isIntercept = true; &#125;else &#123; isIntercept = false; &#125; break; case MotionEvent.ACTION_UP: isIntercept = false; break; default: break; &#125; return isIntercept; &#125; &#125; class WindowTouchListener implements View.OnTouchListener &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //获取触摸点相对于屏幕左上角的坐标 rowX = event.getRawX(); rowY = event.getRawY() - getStatusBarHeight(mContext); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: actionDown(event); break; case MotionEvent.ACTION_MOVE: actionMove(event); break; case MotionEvent.ACTION_UP: actionUp(event); break; case MotionEvent.ACTION_OUTSIDE: actionOutSide(event); break; default: break; &#125; return false; &#125; /** * 手指点击窗口外的事件 * * @param event */ private void actionOutSide(MotionEvent event) &#123; //由于我们在layoutParams中添加了FLAG_WATCH_OUTSIDE_TOUCH标记，那么点击悬浮窗之外时此事件就会被响应 //这里可以用来扩展点击悬浮窗外部响应事件 &#125; /** * 手指抬起事件 * * @param event */ private void actionUp(MotionEvent event) &#123; if (autoAlign) &#123; autoAlign(); &#125; &#125; /** * 拖动事件 * * @param event */ private void actionMove(MotionEvent event) &#123; //拖动事件下一直计算坐标 然后更新悬浮窗位置 updateLocation((rowX - downX),(rowY - downY)); &#125; /** * 更新位置 */ private void updateLocation(float x, float y) &#123; mLayoutParams.x = (int) x; mLayoutParams.y = (int) y; mWindowManager.updateViewLayout(floatView, mLayoutParams); &#125; /** * 手指按下事件 * * @param event */ private void actionDown(MotionEvent event) &#123;// downX = event.getX();// downY = event.getY(); &#125; /** * 自动贴边 */ private void autoAlign() &#123; float fromX = mLayoutParams.x; if (rowX &lt;= mDisplayMetrics.widthPixels / 2) &#123; mLayoutParams.x = 0; &#125; else &#123; mLayoutParams.x = mDisplayMetrics.widthPixels; &#125; //这里使用ValueAnimator来平滑计算起始X坐标到结束X坐标之间的值，并更新悬浮窗位置 ValueAnimator animator = ValueAnimator.ofFloat(fromX, mLayoutParams.x); animator.setDuration(300); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //这里会返回fromX ~ mLayoutParams.x之间经过计算的过渡值 float toX = (float) animation.getAnimatedValue(); //我们直接使用这个值来更新悬浮窗位置 updateLocation(toX, mLayoutParams.y); &#125; &#125;); animator.start(); &#125; &#125; public static class Builder &#123; private Context context; private boolean autoAlign; private boolean modality; private View contentView; private boolean moveAble; /** * @param context 上下文环境 * @param contentView 需要悬浮的视图 */ public Builder(Context context, @NonNull View contentView) &#123; this.context = context.getApplicationContext(); this.contentView = contentView; &#125; /** * 是否自动贴边 * @param autoAlign * @return */ public Builder setAutoAlign(boolean autoAlign) &#123; this.autoAlign = autoAlign; return this; &#125; /** * 是否模态窗口（事件是否可穿透当前窗口） * @param modality * @return */ public Builder setModality(boolean modality) &#123; this.modality = modality; return this; &#125; /** * 是否可拖动 * @param moveAble * @return */ public Builder setMoveAble(boolean moveAble) &#123; this.moveAble = moveAble; return this; &#125; public FloatWindowUtils create() &#123; return new FloatWindowUtils(this); &#125; &#125;&#125; 调用方式 Button mBtn = new Button(this);mBtn.setText(&quot;悬浮按钮&quot;);mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context,&quot;click&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);new FloatWindowUtils.Builder(context,mBtn) .setAutoAlign(true) //自动贴边 .setModality(false) //模态窗体 .setMoveAble(true) //可拖动 .create() .show(); Demo 源码GitHub]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0 FileUriExposedException 的处理]]></title>
    <url>%2F2017%2F05%2F09%2Fandroid-fileuriexposedexception-resolve%2F</url>
    <content type="text"><![CDATA[概述每次 Android 系统大版本升级时，身为 Android 开发者，除了接触新技能的喜悦之外不免也会有提心吊胆的时候，因为这个时候你过去写的 APP 在新系统的环境中随时面临崩溃，这并不是危言耸听，过去 Android 5.0 、6.0 权限控制机制的变动，各种版本的兼容适配想必大家都深有体会，所以每次版本升级时最稳妥的办法就是去官网浏览一遍版本新特性，尽早防患于未然，本文解决的 FileUriExposedException 就是 Android 7.0 版本常见的一个权限适配问题。 发现问题前几天把手机系统升级到 Android 7.0，后来在升级调试一个应用时抛出如下异常信息： android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.skyrin.bingo/cache/app/app.apk exposed beyond app through Intent.getData()at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)...at com.skyrin.bingo.update.AppUpdate.installApk(AppUpdate.java:295) 根据如上日志找到 AppUpdate 类下的 installApk 方法： /** * 安装apk */public static void installApk(Context context,String apkPath) &#123; if (TextUtils.isEmpty(apkPath))&#123; Toast.makeText(context,"更新失败！未找到安装包", Toast.LENGTH_SHORT).show(); return; &#125; File apkFile = new File(apkPath + apkCacheName); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType( Uri.fromFile(apkFile), "application/vnd.android.package-archive"); context.startActivity(intent); //第295行&#125; 问题出在启动安装程序阶段 什么导致了这个问题？由于没升级 7.0 系统之前都没有问题，于是就在 Android 官网查看了一下 Android 7.0 新特性，终于发现其中 “在应用间共享文件” 一栏明确指出了这个问题 这个问题是由于 Android 7.0 权限更改导致，确切的讲是 Android 对权限的进一步管理，从 Android 6.0 的动态权限申请到这个问题可以看出 Google 也是越来越重视 Android 环境的安全问题了。 解决问题官方给出的解决方式是通过 FileProvider 来为所共享的文件 Uri 添加临时权限，详细请看这里 在 标签下添加 FileProvider 节点 &lt;application ...&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.skyrin.bingo.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; ...&lt;/application&gt; android：authority 属性指定要用于 FileProvider 生成的 content URI 的 URI 权限，这里推荐使用 包名.fileprovider 以确保其唯一性。&lt;provider&gt; 的 &lt;meta-data&gt; 子元素指向一个 XML 文件，用于指定要共享的目录。 在 res/xml 目录下创建文件 file_paths.xml 内容如下： &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-cache-path path="app/" name="apk"/&gt;&lt;/paths&gt; &lt;external-cache-path&gt; 表示应用程序内部存储目录下的 cache/ 目录，完整路径为 Android/data/com.xxx.xxx/cache/。path 属性用于指定子目录。name 属性告诉 FileProvider 为 Android/data/com.xxx.xxx/cache/app/ 创建一个名为 apk 的路径字段。想要通过 FileProvider 为文件生成 content URI 只能在此处指定目录，以上示例就表示我将要共享 Android/data/com.xxx.xxx/cache/app/ 这个目录，除此之外还可以共享其它目录，对应的路径如下： 标签 路径 &lt;files-path name=”name” path=”path” /&gt; Context.getFilesDir()) &lt;cache-path name=”name” path=”path” /&gt; getCacheDir()) &lt;external-path name=”name” path=”path” /&gt; Environment.getExternalStorageDirectory()) &lt;external-files-path name=”name” path=”path” /&gt; Context.getExternalFilesDir()) &lt;external-cache-path name=”name” path=”path” /&gt; Context.getExternalCacheDir()) 完成以步骤后，我们修改出问题的代码如下： /** * 安装apk */public static void installApk(Context context,String apkPath) &#123; if (TextUtils.isEmpty(apkPath))&#123; Toast.makeText(context,"更新失败！未找到安装包", Toast.LENGTH_SHORT).show(); return; &#125; File apkFile = new File(apkPath + apkCacheName); Intent intent = new Intent(Intent.ACTION_VIEW); //Android 7.0 系统共享文件需要通过 FileProvider 添加临时权限，否则系统会抛出 FileUriExposedException . if (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.N)&#123; intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context,"com.skyrin.bingo.fileprovider",apkFile); intent.setDataAndType(contentUri,"application/vnd.android.package-archive"); &#125;else &#123; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType( Uri.fromFile(apkFile), "application/vnd.android.package-archive"); &#125; context.startActivity(intent);&#125;...//调用，apkPath 入参就是 xml 中共享的路径String apkPath = context.getExternalCacheDir().getPath()+ File.separator+"app"+File.separator;AppUpdate.installApk(context,apkPath ); 结语除了上面这个问题，在 Android 7.0 之前开发的分享图文、浏览编辑本地图片、共享互传文件等功能如果没有使用 FileProvider 来生成 URI 的话，在 Android 7.0 上就必须做这种适配了，所以平时建议大家多关注 Android 新的 API ，尽早替换已被官方废弃的 API ，实际上 FileProvider 在 API Level 22 已经添加了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 快速启动 Android NDK 项目开发]]></title>
    <url>%2F2017%2F04%2F30%2Fstart-ndk-project%2F</url>
    <content type="text"><![CDATA[概述通过本篇教程，您将学习如何使用 Android Studio 轻松启动 Android NDK 项目开发。 开发环境 Android Studio 2.2 或以上的版本 Android NDK 11c+ 或以上的版本 Android SDK 最新版，这个一般会包含在 Android Studio 中。 Android 5.0+ 测试机或模拟器 创建一个 HelloJni 项目 创建完成如下 配置 Studio 下载安装 NDK，如果你之前已经单独下载过 NDK 也可以在 Project Structure – SDK Location – Android NDK location 下去引用，我更推荐如下方式通过 Android SDK Manager 自动安装，它会将 NDK 放入 /android-sdk/ndk-bundle/ 下 运行项目 将JNI构建功能添加到HelloJni项目中Android Studio 通过 Google 开发的 experimental plugin 支持 native 开发，通过这个插件我们可以不用考虑配置麻烦的 Android.mk 等构建文件就可以进行开发，我们来将其添加到我们的项目中。下面是 experimental 插件与 gradle 的版本对应表，详细查看官方文档，本教程我们将以 experimental plugin 0.7.3 为例 Plugin Version Gradle Version 0.1.0 2.5 0.2.0 2.5 0.3.0-alpha3 2.6 0.4.0 2.8 0.6.0-alpha1 2.8 0.6.0-alpha5 2.10 0.7.0-alpha1 2.10 0.7.0 2.10 0.7.3 2.14.1 对应的我们先配置项目的 gradle 版本为 gradle2.14.1，下载相应版本 gradle 并配置 引用对应版本的 experimental 插件，此处以 0.7.3 版本为例，打开项目的 build.gradle 替换 classpath 'com.android.tools.build:gradle:2.2.0' 为 classpath 'com.android.tools.build:gradle-experimental:0.7.3' 打开模块 的 build.gradle 文件，修改让它支持 experimental 插件的语法 替换 apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.2" defaultConfig &#123; applicationId "com.skyrin.hellojni" minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;... 为 apply plugin: 'com.android.model.application' //&lt;&lt;&lt;model &#123; //&lt;&lt;&lt; android &#123; compileSdkVersion 25 buildToolsVersion "25.0.2" defaultConfig &#123; applicationId "com.skyrin.hellojni" minSdkVersion.apiLevel 15 //&lt;&lt;&lt; targetSdkVersion.apiLevel 25 //&lt;&lt;&lt; versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles.add(file('proguard-android.txt')) //&lt;&lt;&lt; &#125; &#125; &#125;&#125; //&lt;&lt;&lt;... 点击 Sync Now 同步项目 现在可以添加 Jni 代码了 配置模块的 build.gradle 文件让它可以创建 hello-jni 动态链接库也就是 .os 等文件，然后 Sync 项目 buildTypes &#123; ...&#125;//添加ndk&#123; moduleName "hello-jni"&#125; 在 MainActivity 中（当然你也可以新建一个 JniUtils.class 进行封装）创建 native 方法 ...static &#123; System.loadLibrary("hello-jni");&#125;public native String getStrFromJni();... 点击上面提示之后 Studio 会自动为我们创建 cpp 目录以及 .c 文件，c 文件生成代码如下 #include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_skyrin_hellojni_MainActivity_getStrFromJni(JNIEnv *env, jobject instance) &#123; // TODO return (*env)-&gt;NewStringUTF(env, returnValue);&#125; 替换其返回值如下 return (*env)-&gt;NewStringUTF(env, "Hello Jni!"); 调用 native 函数 public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用jni代码 ((TextView)findViewById(R.id.tv_jni)).setText(getStrFromJni()); &#125; static &#123; System.loadLibrary("hello-jni"); &#125; public native String getStrFromJni();&#125; 我们来 Run 一下 用 c 写个加法函数试试 java public native int add(int a,int b); Jni JNIEXPORT jint JNICALLJava_com_skyrin_hellojni_MainActivity_add(JNIEnv *env, jobject instance, jint a, jint b) &#123; // TODO return a+b;&#125; 调用 ((TextView)findViewById(R.id.tv_jni)).setText(add(2,3)+&quot;&quot;); Run 一下 Congratulations! 你学会用 NDK 开发了✧｡٩(^㉨^)و✧*｡]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ndk</tag>
      </tags>
  </entry>
</search>
