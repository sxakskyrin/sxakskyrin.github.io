<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Fiddler 极速上手]]></title>
    <url>%2F2018%2F01%2F14%2Ffiddler-usage%2F</url>
    <content type="text"><![CDATA[概述Fiddler 是一个 http协议 调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出” Fiddler 的数据（指 [cookie] (http://baike.baidu.com/item/cookie/1119) 、html、js、css 等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。 你只需要知道它是一个 “调试代理工具” 就 OK 了，Fiddler 的功能相当强大，网上的教程也有一大堆，本文秉承着从零开始快速上手的理念，所以非必要的地方不会讲的太细，文末推荐了一些写的不错的教程以供喜欢研究的同学仔细研究，如果你英文不错的话直达官方文档任何教程都不用看了，包括本篇。 Fiddler UIFiddler 的界面大概就是下面这个样子 Fiddler 配置下载安装后启动 Fiddler 设置成如下状态，期间需要安装证书 FiddlerRoot.cer。 最后在 Fiddler 命令行中输入 start 并回车，确保其处于 Capturing 状态 Android 端代理设置因为 Fiddler 是 PC 与 服务器之间的代理，而我们需要修改 Android 设备请求的数据包，所以让 PC 作为 Android 设备的代理继而通过 Fiddler 代理 PC 我们就可以在 Fiddler 中抓取到 Android 设备的请求数据了。 保证移动设备与 PC 在同一局域网下 获取 PC 的 IP 地址 设置 Android 设备的 WIFI 代理服务器及端口号（这个端口就是 Fiddler 在一直监听的，默认是 8888） 移动端可以在浏览器中访问 127.0.0.1:8888 来安装证书。如果不安装证书的话只能抓取 HTTP 请求 以上步骤没问题的话，随便打开一个网页，应该就能在 Fiddler 中捕获到移动端的请求会话了。 过滤器 （Filters）上面的步骤中，随便打开一个网页，你可能会看见一堆会话，包括一些其他应用的消息推送，状态同步等待后台网络请求也会显示在会话中，这时就需要过滤掉无用的会话，如下设置后就只显示来自 “weatherapi.market.xiaomi.com” 的会话了，多个 Host 使用 “;” 隔开或一行一个。 检查器 （Inspectors）在检查器中可以预览任意一条会话的详细信息（请求体、响应体等） 自动响应器 （AutoResponder）自动响应器可以模拟一个响应，向符合匹配规则的请求返回自定义内容，匹配规则详细介绍看这里 简单使用场景开发中我们可能会经常遇到这种情况，比如测试登录模块，数据解析调试等场景时，需要多次频繁的请求服务器返回各式各样的数据，可能需要不完整的、有错误的返回结果测试应用的健壮性，需要不同的网络环境来模拟户外使用的场景；如果按照常规方式来测的话可能需要后台给一个测试接口，各种数据后台改一下再请求一次测一下，或者直接把数据放到文件里直接读取，而网络环境更是很难模拟；那么有了 Fiddler ，这种调试就轻松多了，下面是一个简单的修改返回数据示例。 这是 Meizu 系统内置的天气软件 下拉刷新一下数据，可以看到 Fiddler 中捕获到的会话及返回的天气数据 保存返回数据 编辑刚刚保存的 Json 数据，这个 Json 编辑工具不错 在自动响应器中添加匹配规则，修改返回数据为刚才我们改过的文件 再次下拉刷新天气信息，就从文本中返回如下数据了 OK 以上差不多就是 Fiddler 的基础用法了，它还有许多更强大的调试功能和使用场景，喜欢研究的同学可以看看： 零基础学习抓包改包Fiddler自动响应AutoResponder正则匹配官方文档官方文档官方文档]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2 创建虚拟主机]]></title>
    <url>%2F2018%2F01%2F08%2Fapache2-to-create-a-virtual-host%2F</url>
    <content type="text"><![CDATA[概述术语虚拟主机指的是在单一机器上运行多个网站 (例如 company1.example.com 和 company2.example.com) 。 虚拟主机可以“基于 IP”，即每个 IP 一个站点； 或者“基于名称”， 即每个 IP 多个站点。这些站点运行在同一物理服务器上的事实不会明显的透漏给最终用户。 基础概念虚拟主机Apache 是第一个支持基于 IP 的虚拟主机的服务器。 Apache 版本 1.1 和更新的版本同时支持基于 IP 和基于名称的虚拟主机。 基于名称的虚拟主机有时候称为基于主机或非 IP 的虚拟主机. 以下解释是在 Apache 中支持虚拟主机的所有详细信息的文档页面列表。 虚拟主机支持的配置 基于名称的虚拟主机 (每个 IP 多个站点) 基于 IP 的虚拟主机 (每个 IP 一个站点) 虚拟主机样例 文件句柄限制 (应用于日志文件太多) 动态配置的大规模虚拟主机 虚拟主机匹配的深入讨论 配置指令 &lt;VirtualHost&gt; ServerName ServerAlias ServerPath 配置 Apache HTTP Server 侦听特定端口和地址 相关模块 相关指令 core &lt;VirtualHost&gt; mpm_common Listen 当httpd启动时，它绑定到本地机器上的一些端口和地址，并等待传入​​的请求。默认情况下，它监听机器上的所有地址。但是，可能需要通知您在特定的端口上进行监听，或者只监听选定的地址或两者的组合。这通常与虚拟主机功能相结合， 虚拟主机功能决定了如何 httpd响应不同的IP地址，主机名和端口。 该Listen 指令告诉服务器仅接受指定端口或地址和端口组合上的传入请求。如果在Listen 指令中仅指定一个端口号，则服务器将侦听所有接口上的给定端口。如果IP地址和端口一样，服务器将监听给定的端口和接口。Listen可以使用多个指令来指定多个地址和端口进行侦听。服务器将响应来自任何列出的地址和端口的请求。 例如，使服务器接收所有地址的 80、8000 端口请求： Listen 80 Listen 8000 使服务器接收指定地址的 80、8000 端口请求： Listen 192.0.2.1:80 Listen 192.0.2.5:8000 用 Listen 指定协议 大多数 Listen 配置不需要可选的第二协议参数。如果未指定，https 协议则是端口 443 的默认值，http 协议为所有其他端口默认值。该协议用于确定哪个模块应该处理请求，以及使用该 AcceptFilter 指令应用协议特定的优化。 如果您在非标准端口上运行，则只需设置协议。例如，使用 https 协议在端口 8443 上运行一个站点： Listen 192.170.2.1:8443 https Listen 与虚拟主机是如何协同工作的 Listen 指令不实现虚拟主机 - 它只告诉主服务器要监听的地址和端口。如果不使用&lt;VirtualHost&gt; 指令，则服务器对于所有接受的请求将以相同的方式处理。但是，&lt;VirtualHost&gt; 可以用来为一个或多个地址或端口指定不同的行为。要实现VirtualHost，服务器必须先被告知要使用的地址和端口。然后&lt;VirtualHost&gt;为指定的地址和端口创建一个配置来设置这个虚拟主机的行为。请注意，如果&lt;VirtualHost&gt;设置为服务器未侦听的地址和端口，则无法访问。 配置虚拟主机上传站点到服务器 Apache 站点根目录位于 /var/www/ ，新上传站点应位于 www 目录下，站点目录命名规则推荐使用 domain-port 创建站点目录 $ cd /var/www $ mkdir domain-7777 上传请注意 index.html 应位于 domain-7777 目录 创建虚拟主机配置文件 $ cd /etc/apache2/sites-available/ $ vim 7777-ssl.conf 输入如下配置并保存 Listen 7777 &lt;IfModule mod_ssl.c&gt; &lt;VirtualHost *:7777&gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request&apos;s Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost ServerName rak.example.com DocumentRoot /var/www/domain-7777 # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with &quot;a2disconf&quot;. #Include conf-available/serve-cgi-bin.conf SSLCertificateFile /etc/letsencrypt/live/rak.example.com/cert.pem SSLCertificateKeyFile /etc/letsencrypt/live/rak.example.com/privkey.pem Include /etc/letsencrypt/options-ssl-apache.conf SSLCertificateChainFile /etc/letsencrypt/live/rak.example.com/chain.pem &lt;/VirtualHost&gt; &lt;/IfModule&gt; 使 7777-ssl.conf 配置生效 Apache 配置文件默认放在 -available 后缀的目录下，-enabled 后缀目录下放的是配置文件的引用，而 Apache 服务启动时只会加载 -enabled 后缀目录下的引用；Apache 这么做的目的是为了便于配置文件的管理，比如你要关闭一个虚拟主机，只需删除-enabled 后缀目录下相关虚拟主机的配置引用即可，而不必删除此虚拟主机配置文件本身，需要再次启动此虚拟主机时，只需要再次添加此虚拟主机相应配置文件的引用到 -enabled 后缀目录下即可 所以，这里除了创建 7777-ssl.conf 配置文件，还需要将其引用到 sites-enabled/ 下 $ ln -s /etc/apache2/site-available/7777-ssl.conf /etc/apache2/site-enabled/7777-ssl.conf 使用 a2ensite 命令启动虚拟主机，使用 a2dissite 命令停止虚拟主机 $ a2ensite 7777-ssl.conf $ service apache2 reload 检查端口 7777 是否正常被侦听 $ netstat -a | grep &apos;:7777&apos; 正常状态会查到如下结果 tcp 0 0 *:7777 *:* LISTEN 如果没有结果，请尝试重启 Apache 服务器 $ service apache2 restart 现在，输入 https://rak.example.com:7777 即可访问位于/var/www/domain-7777/下的站点了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 的文件操作]]></title>
    <url>%2F2017%2F11%2F16%2Fgradle-file-operation%2F</url>
    <content type="text"><![CDATA[概述众所周知，Gradle 作为一个项目构建工具，使用了 Groovy 语言来表述其脚本代码，而 Groovy 语言中的很多特性设计的有点“反人类”，这些特性对于老手来说写起来非常舒服，但是对于新手就很不友好了，因为不便于理解，很多萌新看着 Gradle 的脚本感觉很简单很清晰的样子，但是真到了自己去写的时候就会感觉无从下手，怎么写怎么报错；本文就从Gradle 的几个简单的文件操作顺带来分析一下这些奇葩的坑点，让大家对 Groovy 语法特性有个大致认知。 准备一个文件目录如下：点击下载 准确的Tree结构:root│ build.gradle│ solution.gradle│ └──src ├──docs │ aa.aa │ install.md │ install.txt │ readme.txt │ └──web │ index.html │ └──images cat.jpg dog.jpg 任务1) 拷贝src/web目录到build/web目录，并且拷贝src/docs目录下的所有 txt 文件到build/web/help下。2) 打包build/web目录下除 images 文件夹外的所有文件为web.zip，并将web.zip放置于build目录下。3) 解压build/web.zip到build/exploded4) 删除build/web/help 解决方案//1.Copytask copyWeb(type:Copy)&#123; from 'src/web' from ('src/docs')&#123; include '*.txt' into 'help' &#125; into 'build/web'&#125;//2.Ziptask bundleWeb(type:Zip,dependsOn:copyWeb)&#123; baseName 'web' destinationDir file('build') from 'build/web' exclude 'images/**'&#125;//3.UnZiptask unpackBundle(type:Copy,dependsOn:bundleWeb)&#123; from zipTree('build/web.zip') into 'build/exploded'&#125;//4.Deletetask deleteHelp(type:Delete,dependsOn:copyWeb)&#123; delete 'build/web/help'&#125; 是的你没有看错，任务中的4个问题就用上面这20几行代码轻松解决；但是，你可能还是不太清楚这些这些配置的规则，它们看上去就像一堆键值对类似于Json，然而实际上它们都是由属性和方法构成的，就像Java一样： 属性 描述 类型 excludes 排除模式集合 Set includes 包含模式集合 Set baseName 文件的基本名称 String destinationDir 文件生成的目录 File 方法 描述 返回 from(sourcePaths)) 指定副本的源文件或目录 AbstractCopyTask include(includes)) 指定包含模式 AbstractCopyTask exclude(excludes)) 指定排除模式 AbstractCopyTask into(destDir)) 指定副本的目标目录 AbstractCopyTask 所以上面解决方案的完整写法：//1.Copytask copyWeb(type:Copy)&#123; from(&apos;src/web&apos;) from(&apos;src/docs&apos;)&#123; include(&apos;*.txt&apos;) into(&apos;help&apos;) &#125; into(&apos;build/web&apos;)&#125;//2.Ziptask bundleWeb(type:Zip,dependsOn:copyWeb)&#123; baseName=&apos;web&apos; destinationDir=file(&apos;build&apos;) from(&apos;build/web&apos;) exclude(&apos;images/**&apos;)&#125;//3.UnZiptask unpackBundle(type:Copy,dependsOn:bundleWeb)&#123; from(zipTree(&apos;build/web.zip&apos;)) into(&apos;build/exploded&apos;)&#125;//4.Deletetask deleteHelp(type:Delete,dependsOn:copyWeb)&#123; delete(&apos;build/web/help&apos;)&#125; 这样看起来就清晰多了，以上脚本中用到的所有方法及属性都可以在 Gradle DSL Reference 文档中查到，该文档详尽的解释了每个方法及参数的作用，由于 Groovy 语言的特性，一般 Gradle 脚本都会使用简写的方式，也就是省略掉‘()’、‘=’等符号，因为省略掉这些符号不会影响到语法歧义，说到歧义大家可以看到 3.UnZip 中有一行代码 from(zipTree(&#39;build/web.zip&#39;)) 即使简写也只能写成 from zipTree(&#39;build/web.zip&#39;) 而非 from zipTree &#39;build/web.zip&#39;，因为最后这种写法显然使 Groovy 无法理解你要将 &#39;build/web.zip&#39; 作为 zipTree 的参数还是 from 的参数 其实在任何一种计算机语言中各种‘()’、‘[]’、‘{}’都是为了避免产生语法歧义，只要你掌握其中规则，知道怎么写才能避免歧义使代码正常运作，再了解其特有的语言特性如闭包、lambda、委托等，你就大致掌握了这门语言。现在再来看看 Groovy ，它其实就是一种不需要 public修饰符、类型说明、构造函数以及 （）的 Java简化版。]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FloatWindowUtils 实现及事件冲突解决详解]]></title>
    <url>%2F2017%2F05%2F31%2Ffloat-window-utils%2F</url>
    <content type="text"><![CDATA[概述悬浮窗即可以显示在宿主应用之外的 View 视图，理论上任何 View 都能以悬浮窗形式展示在宿主应用之外甚至锁屏界面，一般在工具类应用中使用的比较多，通过悬浮窗可以很方便的从外界与宿主应用进行交互，例如金山词霸的锁屏单词功能、AirDroid 的录制屏幕菜单、360优化大师的清理悬浮按钮等。 需要了解的Window Window 表示一个窗口的概念，在日常开发中直接接触 Window 的机会并不多，但是在特殊时候我们需要在桌面显示一个类似悬浮窗的东西，那么这种效果就需要用到 Window 来实现。Window 是一个抽象类，它的具体实现是 PhoneWindow。创建一个 Window 非常简单，我们通过 WindowManager 即可完成。 Android 中所有视图都是通过 Window 来呈现的，不管是 Activity、Dialog、还是 Toast，它们的视图实际上都是附加在 Window 上的。 WindowManager 应用程序用于与窗口管理器通信的接口，是外界访问 Window 的入口，使用 Context.getSystemService(Context.WINDOW_SERVICE) 获取它的实例。WindowManager提供了 addView(View view, ViewGroup.LayoutParams params)，removeView(View view)，updateViewLayout(View view, ViewGroup.LayoutParams params) 三个方法用来向设备屏幕 添加、移除以及更新 一个 view 。 WindowManager.LayoutParams 通过名字就可以看出来 它是WindowManager的一个内部类，专门用来描述 view 的属性 比如大小、透明度 、初始位置、视图层级等。 DisplayMetrics 该对象用来描述关于显示器的一些信息，例如其大小，密度和字体缩放。例如获取屏幕宽度DisplayMetrics.widthPixels 。 最终效果 实现思路本着实现一个简单的、轻量级的工具类的目的，通过传入一个任意 View 可以将其创建成可自由拖动的悬浮窗 悬浮一个 View 首先我们知道 View 能显示在屏幕上其实是间接通过 Window 管理的，那么我们就可以使用 WindowManager 来管理它，让它具备悬浮的属性，下面代码演示了通过 WindowManager 添加 Window 的过程，非常简单 final Button mBtn = new Button(this);mBtn.setText("悬浮按钮");mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context,"click",Toast.LENGTH_SHORT).show(); &#125;&#125;);final WindowManager.LayoutParams mLayoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT ,WindowManager.LayoutParams.WRAP_CONTENT,0,0, PixelFormat.TRANSPARENT);mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP; //view 处于屏幕的相对位置，注意这里必须是 LEFT &amp; TOP，因为 Android 设备屏幕坐标原点在左上角mLayoutParams.x = 100; //距离屏幕左侧100pxmLayoutParams.y = 300; //距离屏幕上方300pxmLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; //指定 Window 类型为 TYPE_SYSTEM_ALERT，属于系统级别，就可以显示在系统屏幕上了final WindowManager mWindowManager = getWindowManager();mWindowManager.addView(mBtn,mLayoutParams); 别忘了系统级窗口权限 &lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; 效果如下 使其可以拖动 显然上面的 Button 只是能显示在系统屏幕上而已，并不能拖动，要使其能够拖动就要给它设置一个 View.OnTouchListener 来监听手指在屏幕上滑动的坐标然后根据这个坐标设置其位置，如下实现 mBtn.setOnTouchListener(new View.OnTouchListener() &#123; //触摸点相对于view左上角的坐标 float downX; float downY; @Override public boolean onTouch(View v, MotionEvent event) &#123; //获取触摸点相对于屏幕左上角的坐标 float rowX = event.getRawX(); float rowY = event.getRawY() - getStatusBarHeight(context); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = event.getX(); downY = event.getY(); break; case MotionEvent.ACTION_MOVE: mLayoutParams.x = (int) (rowX - downX); //计算当前触摸点相对于屏幕左上角的 X 轴位置 mLayoutParams.y = (int) (rowY - downY); //计算当前触摸点相对于屏幕左上角的 Y 轴位置 mWindowManager.updateViewLayout(mBtn, mLayoutParams); //更新 Button 到相应位置 break; case MotionEvent.ACTION_UP: //actionUp(event); break; case MotionEvent.ACTION_OUTSIDE: //actionOutSide(event); break; default: break; &#125; return false; &#125;&#125;); 解决点击和滑动的事件冲突 现在这个 Button 虽然可以跟着你的手指移动了，但是你会发现当你拖动一段较小距离时会有很大几率响应它的 Click 事件，这显然不能接受，在拖动这个 Button 的整个过程中会依次触发 ACTION_DOWN、ACTION_MOVE、ACTION_MOVE、… 、ACTION_UP，当 ACTION_MOVE 被触发时 ACTION_DOWN 会被释放，之后松开手指触发 ACTION_UP 是不会响应 Click 事件的， Click 事件的响应条件是 ACTION_DOWN + ACTION_UP，所以当我们拖动一个很小的距离时很容易造成 ACTION_DOWN 与 ACTION_UP 的连续触发而响应了 Click 事件，尤其是在 DPI 较高的设备上，下面是一个根据最小偏移量来判断是否应该响应 Click 事件的一种方式 ...//拖动的最小偏移量int MIN_OFFSET = 5;//是否视为 click 事件boolean isClick = false;@Overridepublic boolean onTouch(View v, MotionEvent event) &#123; ... switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: isClick = true; ... break; case MotionEvent.ACTION_MOVE: ... // 通过拖拽的距离是否超过最小偏移量来判断点击事件 if (Math.abs((rowX - downX)) &gt; MIN_OFFSET &amp;&amp; Math.abs((rowY - downY)) &gt; MIN_OFFSET)&#123; isClick = false; &#125;else &#123; isClick = true; &#125; break; case MotionEvent.ACTION_UP: if (isClick)&#123; // 执行点击事件 &#125; break; default: break; &#125; return false;&#125; 最终改进 上述方式固然可以解决冲突问题，但是点击事件被放在 ACTION_UP 之下，或需要整个接口在外面调用很不优雅，下面的解决办法是通过父级 View 进行拦截，也就是将所有传进来的 View 先放入一个 ViewGroup 中，给这个 ViewGroup 设置 View.OnTouchListener，重写这个 ViewGroup 的 onInterceptTouchEvent 方法，根据拖拽的意图让它决定是否拦截所有事件不向下传递，从根本上解决冲突，并且把设置 Window 的属性相关也集成进去，外界只需传入一个 View 即可，下面是 FloatWindowUtils 全部实现过程 public class FloatWindowUtils &#123; private WindowManager.LayoutParams mLayoutParams; private WindowManager mWindowManager; private DisplayMetrics mDisplayMetrics; //view 相对于屏幕触摸点的偏移量(一般仅减去Y轴状态栏高度) int offsetX; int offsetY; //触摸点相对于view左上角的坐标 float downX; float downY; //触摸点相对于屏幕左上角的坐标 float rowX; float rowY; //悬浮窗显示标记 boolean isShowing; //拖动最小偏移量 private static final int MINIMUM_OFFSET = 5; private Context mContext; //是否自动贴边 private boolean autoAlign; //是否模态窗口 private boolean modality; //是否可拖动 private boolean moveAble; //内部定义的View，专门处理事件拦截的父View private FloatView floatView; //外部传进来的需要悬浮的View private View contentView; public FloatWindowUtils(Builder builder) &#123; this.mContext = builder.context; this.autoAlign = builder.autoAlign; this.modality = builder.modality; this.contentView = builder.contentView; this.moveAble = builder.moveAble; initWindowManager(); initLayoutParams(); initFloatView(); &#125; private void initWindowManager() &#123; mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); //获取一个DisplayMetrics对象，该对象用来描述关于显示器的一些信息，例如其大小，密度和字体缩放。 mDisplayMetrics = new DisplayMetrics(); mWindowManager.getDefaultDisplay().getMetrics(mDisplayMetrics); &#125; private void initFloatView() &#123; floatView = new FloatView(mContext); if (moveAble) &#123; floatView.setOnTouchListener(new WindowTouchListener()); &#125; &#125; private void initLayoutParams() &#123; mLayoutParams = new WindowManager.LayoutParams(); mLayoutParams.flags = WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_DIM_BEHIND; if (modality) &#123; mLayoutParams.flags &amp;= ~WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL; mLayoutParams.flags &amp;= ~WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; &#125; mLayoutParams.height = LinearLayout.LayoutParams.WRAP_CONTENT; mLayoutParams.width = LinearLayout.LayoutParams.WRAP_CONTENT; mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP; mLayoutParams.format = PixelFormat.RGBA_8888; //此处mLayoutParams.type不建议使用TYPE_TOAST，因为在一些三方ROM中会出现拖动异常的问题，虽然它不需要权限 mLayoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; //悬浮窗背景明暗度0~1，数值越大背景越暗，只有在flags设置了WindowManager.LayoutParams.FLAG_DIM_BEHIND 这个属性才会生效 mLayoutParams.dimAmount = 0.0f; //悬浮窗透明度0~1，数值越大越不透明 mLayoutParams.alpha = 0.8f; offsetX = 0; offsetY = getStatusBarHeight(mContext); //设置初始位置 mLayoutParams.x = mDisplayMetrics.widthPixels - offsetX; mLayoutParams.y = mDisplayMetrics.widthPixels*3/4 - offsetY; &#125; /** * 将窗体添加到屏幕上 */ public void show() &#123; if (!isAppOps(mContext))&#123;// openOpsSettings(mContext);// Toast.makeText(mContext,"需要授权应用悬浮权限",Toast.LENGTH_SHORT).show(); return; &#125; if (!isShowing()) &#123; mWindowManager.addView(floatView, mLayoutParams); isShowing = true; &#125; &#125; /** * 悬浮窗是否正在显示 * * @return true if it's showing. */ private boolean isShowing() &#123; if (floatView != null &amp;&amp; floatView.getVisibility() == View.VISIBLE) &#123; return isShowing; &#125; return false; &#125; /** * 打开悬浮窗设置页 * 部分第三方ROM无法直接跳转可使用&#123;@link #openAppSettings(Context)&#125;跳到应用详情页 * * @param context * @return true if it's open successful. */ public static boolean openOpsSettings(Context context)&#123; try &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + context.getPackageName())); context.startActivity(intent); &#125;catch (Exception e)&#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 打开应用详情页 * @param context * @return true if it's open success. */ public static boolean openAppSettings(Context context)&#123; try &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts("package", context.getPackageName(), null); intent.setData(uri); context.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 判断 悬浮窗口权限是否打开 * 由于android未提供直接跳转到悬浮窗设置页的api，此方法使用反射去查找相关函数进行跳转 * 部分第三方ROM可能不适用 * @param context * @return true 允许 false禁止 */ public static boolean isAppOps(Context context) &#123; try &#123; Object object = context.getSystemService(Context.APP_OPS_SERVICE); if (object == null) &#123; return false; &#125; Class localClass = object.getClass(); Class[] arrayOfClass = new Class[3]; arrayOfClass[0] = Integer.TYPE; arrayOfClass[1] = Integer.TYPE; arrayOfClass[2] = String.class; Method method = localClass.getMethod("checkOp", arrayOfClass); if (method == null) &#123; return false; &#125; Object[] arrayOfObject1 = new Object[3]; arrayOfObject1[0] = Integer.valueOf(24); arrayOfObject1[1] = Integer.valueOf(Binder.getCallingUid()); arrayOfObject1[2] = context.getPackageName(); int m = ((Integer) method.invoke(object, arrayOfObject1)).intValue(); return m == AppOpsManager.MODE_ALLOWED; &#125; catch (Exception ex) &#123; &#125; return false; &#125; /** * 移除悬浮窗 */ public void remove() &#123; if (isShowing()) &#123; floatView.removeView(contentView); mWindowManager.removeView(floatView); isShowing = false; &#125; &#125; /** * 用于获取系统状态栏的高度。 * * @return 返回状态栏高度的像素值。 */ public static int getStatusBarHeight(Context ctx) &#123; int Identifier = ctx.getResources().getIdentifier("status_bar_height", "dimen", "android"); if (Identifier &gt; 0) &#123; return ctx.getResources().getDimensionPixelSize(Identifier); &#125; return 0; &#125; class FloatView extends LinearLayout&#123; //记录按下位置 int interceptX=0; int interceptY=0; public FloatView(Context context) &#123; super(context); //这里由于一个ViewGroup不能add一个已经有Parent的contentView,所以需要先判断contentView是否有Parent //如果有则需要将contentView先移除 if (contentView.getParent()!=null&amp;&amp;contentView.getParent() instanceof ViewGroup)&#123; ((ViewGroup) contentView.getParent()).removeView(contentView); &#125; addView(contentView); &#125; /** * 解决点击与拖动冲突的关键代码 * @param ev * @return */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; //此回调如果返回true则表示拦截TouchEvent由自己处理，false表示不拦截TouchEvent分发出去由子view处理 //解决方案：如果是拖动父View则返回true调用自己的onTouch改变位置，是点击则返回false去响应子view的点击事件 boolean isIntercept = false; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: interceptX = (int) ev.getX(); interceptY = (int) ev.getY(); downX = ev.getX(); downY = ev.getY(); isIntercept = false; break; case MotionEvent.ACTION_MOVE: //在一些dpi较高的设备上点击view很容易触发 ACTION_MOVE，所以此处做一个过滤 if (Math.abs(ev.getX()-interceptX)&gt;MINIMUM_OFFSET&amp;&amp;Math.abs(ev.getY()-interceptY)&gt;MINIMUM_OFFSET)&#123; isIntercept = true; &#125;else &#123; isIntercept = false; &#125; break; case MotionEvent.ACTION_UP: isIntercept = false; break; default: break; &#125; return isIntercept; &#125; &#125; class WindowTouchListener implements View.OnTouchListener &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //获取触摸点相对于屏幕左上角的坐标 rowX = event.getRawX(); rowY = event.getRawY() - getStatusBarHeight(mContext); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: actionDown(event); break; case MotionEvent.ACTION_MOVE: actionMove(event); break; case MotionEvent.ACTION_UP: actionUp(event); break; case MotionEvent.ACTION_OUTSIDE: actionOutSide(event); break; default: break; &#125; return false; &#125; /** * 手指点击窗口外的事件 * * @param event */ private void actionOutSide(MotionEvent event) &#123; //由于我们在layoutParams中添加了FLAG_WATCH_OUTSIDE_TOUCH标记，那么点击悬浮窗之外时此事件就会被响应 //这里可以用来扩展点击悬浮窗外部响应事件 &#125; /** * 手指抬起事件 * * @param event */ private void actionUp(MotionEvent event) &#123; if (autoAlign) &#123; autoAlign(); &#125; &#125; /** * 拖动事件 * * @param event */ private void actionMove(MotionEvent event) &#123; //拖动事件下一直计算坐标 然后更新悬浮窗位置 updateLocation((rowX - downX),(rowY - downY)); &#125; /** * 更新位置 */ private void updateLocation(float x, float y) &#123; mLayoutParams.x = (int) x; mLayoutParams.y = (int) y; mWindowManager.updateViewLayout(floatView, mLayoutParams); &#125; /** * 手指按下事件 * * @param event */ private void actionDown(MotionEvent event) &#123;// downX = event.getX();// downY = event.getY(); &#125; /** * 自动贴边 */ private void autoAlign() &#123; float fromX = mLayoutParams.x; if (rowX &lt;= mDisplayMetrics.widthPixels / 2) &#123; mLayoutParams.x = 0; &#125; else &#123; mLayoutParams.x = mDisplayMetrics.widthPixels; &#125; //这里使用ValueAnimator来平滑计算起始X坐标到结束X坐标之间的值，并更新悬浮窗位置 ValueAnimator animator = ValueAnimator.ofFloat(fromX, mLayoutParams.x); animator.setDuration(300); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //这里会返回fromX ~ mLayoutParams.x之间经过计算的过渡值 float toX = (float) animation.getAnimatedValue(); //我们直接使用这个值来更新悬浮窗位置 updateLocation(toX, mLayoutParams.y); &#125; &#125;); animator.start(); &#125; &#125; public static class Builder &#123; private Context context; private boolean autoAlign; private boolean modality; private View contentView; private boolean moveAble; /** * @param context 上下文环境 * @param contentView 需要悬浮的视图 */ public Builder(Context context, @NonNull View contentView) &#123; this.context = context.getApplicationContext(); this.contentView = contentView; &#125; /** * 是否自动贴边 * @param autoAlign * @return */ public Builder setAutoAlign(boolean autoAlign) &#123; this.autoAlign = autoAlign; return this; &#125; /** * 是否模态窗口（事件是否可穿透当前窗口） * @param modality * @return */ public Builder setModality(boolean modality) &#123; this.modality = modality; return this; &#125; /** * 是否可拖动 * @param moveAble * @return */ public Builder setMoveAble(boolean moveAble) &#123; this.moveAble = moveAble; return this; &#125; public FloatWindowUtils create() &#123; return new FloatWindowUtils(this); &#125; &#125;&#125; 调用方式 Button mBtn = new Button(this);mBtn.setText(&quot;悬浮按钮&quot;);mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context,&quot;click&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);new FloatWindowUtils.Builder(context,mBtn) .setAutoAlign(true) //自动贴边 .setModality(false) //模态窗体 .setMoveAble(true) //可拖动 .create() .show(); Demo 源码GitHub]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0 FileUriExposedException 的处理]]></title>
    <url>%2F2017%2F05%2F09%2Fandroid-fileuriexposedexception-resolve%2F</url>
    <content type="text"><![CDATA[概述每次 Android 系统大版本升级时，身为 Android 开发者，除了接触新技能的喜悦之外不免也会有提心吊胆的时候，因为这个时候你过去写的 APP 在新系统的环境中随时面临崩溃，这并不是危言耸听，过去 Android 5.0 、6.0 权限控制机制的变动，各种版本的兼容适配想必大家都深有体会，所以每次版本升级时最稳妥的办法就是去官网浏览一遍版本新特性，尽早防患于未然，本文解决的 FileUriExposedException 就是 Android 7.0 版本常见的一个权限适配问题。 发现问题前几天把手机系统升级到 Android 7.0，后来在升级调试一个应用时抛出如下异常信息： android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.skyrin.bingo/cache/app/app.apk exposed beyond app through Intent.getData()at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)...at com.skyrin.bingo.update.AppUpdate.installApk(AppUpdate.java:295) 根据如上日志找到 AppUpdate 类下的 installApk 方法： /** * 安装apk */public static void installApk(Context context,String apkPath) &#123; if (TextUtils.isEmpty(apkPath))&#123; Toast.makeText(context,"更新失败！未找到安装包", Toast.LENGTH_SHORT).show(); return; &#125; File apkFile = new File(apkPath + apkCacheName); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType( Uri.fromFile(apkFile), "application/vnd.android.package-archive"); context.startActivity(intent); //第295行&#125; 问题出在启动安装程序阶段 什么导致了这个问题？由于没升级 7.0 系统之前都没有问题，于是就在 Android 官网查看了一下 Android 7.0 新特性，终于发现其中 “在应用间共享文件” 一栏明确指出了这个问题 这个问题是由于 Android 7.0 权限更改导致，确切的讲是 Android 对权限的进一步管理，从 Android 6.0 的动态权限申请到这个问题可以看出 Google 也是越来越重视 Android 环境的安全问题了。 解决问题官方给出的解决方式是通过 FileProvider 来为所共享的文件 Uri 添加临时权限，详细请看这里 在 标签下添加 FileProvider 节点 &lt;application ...&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.skyrin.bingo.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; ...&lt;/application&gt; android：authority 属性指定要用于 FileProvider 生成的 content URI 的 URI 权限，这里推荐使用 包名.fileprovider 以确保其唯一性。&lt;provider&gt; 的 &lt;meta-data&gt; 子元素指向一个 XML 文件，用于指定要共享的目录。 在 res/xml 目录下创建文件 file_paths.xml 内容如下： &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-cache-path path="app/" name="apk"/&gt;&lt;/paths&gt; &lt;external-cache-path&gt; 表示应用程序内部存储目录下的 cache/ 目录，完整路径为 Android/data/com.xxx.xxx/cache/。path 属性用于指定子目录。name 属性告诉 FileProvider 为 Android/data/com.xxx.xxx/cache/app/ 创建一个名为 apk 的路径字段。想要通过 FileProvider 为文件生成 content URI 只能在此处指定目录，以上示例就表示我将要共享 Android/data/com.xxx.xxx/cache/app/ 这个目录，除此之外还可以共享其它目录，对应的路径如下： 标签 路径 &lt;files-path name=”name” path=”path” /&gt; Context.getFilesDir()) &lt;cache-path name=”name” path=”path” /&gt; getCacheDir()) &lt;external-path name=”name” path=”path” /&gt; Environment.getExternalStorageDirectory()) &lt;external-files-path name=”name” path=”path” /&gt; Context.getExternalFilesDir()) &lt;external-cache-path name=”name” path=”path” /&gt; Context.getExternalCacheDir()) 完成以步骤后，我们修改出问题的代码如下： /** * 安装apk */public static void installApk(Context context,String apkPath) &#123; if (TextUtils.isEmpty(apkPath))&#123; Toast.makeText(context,"更新失败！未找到安装包", Toast.LENGTH_SHORT).show(); return; &#125; File apkFile = new File(apkPath + apkCacheName); Intent intent = new Intent(Intent.ACTION_VIEW); //Android 7.0 系统共享文件需要通过 FileProvider 添加临时权限，否则系统会抛出 FileUriExposedException . if (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.N)&#123; intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(context,"com.skyrin.bingo.fileprovider",apkFile); intent.setDataAndType(contentUri,"application/vnd.android.package-archive"); &#125;else &#123; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType( Uri.fromFile(apkFile), "application/vnd.android.package-archive"); &#125; context.startActivity(intent);&#125;...//调用，apkPath 入参就是 xml 中共享的路径String apkPath = context.getExternalCacheDir().getPath()+ File.separator+"app"+File.separator;AppUpdate.installApk(context,apkPath ); 结语除了上面这个问题，在 Android 7.0 之前开发的分享图文、浏览编辑本地图片、共享互传文件等功能如果没有使用 FileProvider 来生成 URI 的话，在 Android 7.0 上就必须做这种适配了，所以平时建议大家多关注 Android 新的 API ，尽早替换已被官方废弃的 API ，实际上 FileProvider 在 API Level 22 已经添加了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 快速启动 Android NDK 项目开发]]></title>
    <url>%2F2017%2F04%2F30%2Fstart-ndk-project%2F</url>
    <content type="text"><![CDATA[概述通过本篇教程，您将学习如何使用 Android Studio 轻松启动 Android NDK 项目开发。 开发环境 Android Studio 2.2 或以上的版本 Android NDK 11c+ 或以上的版本 Android SDK 最新版，这个一般会包含在 Android Studio 中。 Android 5.0+ 测试机或模拟器 创建一个 HelloJni 项目 创建完成如下 配置 Studio 下载安装 NDK，如果你之前已经单独下载过 NDK 也可以在 Project Structure – SDK Location – Android NDK location 下去引用，我更推荐如下方式通过 Android SDK Manager 自动安装，它会将 NDK 放入 /android-sdk/ndk-bundle/ 下 运行项目 将JNI构建功能添加到HelloJni项目中Android Studio 通过 Google 开发的 experimental plugin 支持 native 开发，通过这个插件我们可以不用考虑配置麻烦的 Android.mk 等构建文件就可以进行开发，我们来将其添加到我们的项目中。下面是 experimental 插件与 gradle 的版本对应表，详细查看官方文档，本教程我们将以 experimental plugin 0.7.3 为例 Plugin Version Gradle Version 0.1.0 2.5 0.2.0 2.5 0.3.0-alpha3 2.6 0.4.0 2.8 0.6.0-alpha1 2.8 0.6.0-alpha5 2.10 0.7.0-alpha1 2.10 0.7.0 2.10 0.7.3 2.14.1 对应的我们先配置项目的 gradle 版本为 gradle2.14.1，下载相应版本 gradle 并配置 引用对应版本的 experimental 插件，此处以 0.7.3 版本为例，打开项目的 build.gradle 替换 classpath 'com.android.tools.build:gradle:2.2.0' 为 classpath 'com.android.tools.build:gradle-experimental:0.7.3' 打开模块 的 build.gradle 文件，修改让它支持 experimental 插件的语法 替换 apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.2" defaultConfig &#123; applicationId "com.skyrin.hellojni" minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;... 为 apply plugin: 'com.android.model.application' //&lt;&lt;&lt;model &#123; //&lt;&lt;&lt; android &#123; compileSdkVersion 25 buildToolsVersion "25.0.2" defaultConfig &#123; applicationId "com.skyrin.hellojni" minSdkVersion.apiLevel 15 //&lt;&lt;&lt; targetSdkVersion.apiLevel 25 //&lt;&lt;&lt; versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles.add(file('proguard-android.txt')) //&lt;&lt;&lt; &#125; &#125; &#125;&#125; //&lt;&lt;&lt;... 点击 Sync Now 同步项目 现在可以添加 Jni 代码了 配置模块的 build.gradle 文件让它可以创建 hello-jni 动态链接库也就是 .os 等文件，然后 Sync 项目 buildTypes &#123; ...&#125;//添加ndk&#123; moduleName "hello-jni"&#125; 在 MainActivity 中（当然你也可以新建一个 JniUtils.class 进行封装）创建 native 方法 ...static &#123; System.loadLibrary("hello-jni");&#125;public native String getStrFromJni();... 点击上面提示之后 Studio 会自动为我们创建 cpp 目录以及 .c 文件，c 文件生成代码如下 #include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_skyrin_hellojni_MainActivity_getStrFromJni(JNIEnv *env, jobject instance) &#123; // TODO return (*env)-&gt;NewStringUTF(env, returnValue);&#125; 替换其返回值如下 return (*env)-&gt;NewStringUTF(env, "Hello Jni!"); 调用 native 函数 public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用jni代码 ((TextView)findViewById(R.id.tv_jni)).setText(getStrFromJni()); &#125; static &#123; System.loadLibrary("hello-jni"); &#125; public native String getStrFromJni();&#125; 我们来 Run 一下 用 c 写个加法函数试试 java public native int add(int a,int b); Jni JNIEXPORT jint JNICALLJava_com_skyrin_hellojni_MainActivity_add(JNIEnv *env, jobject instance, jint a, jint b) &#123; // TODO return a+b;&#125; 调用 ((TextView)findViewById(R.id.tv_jni)).setText(add(2,3)+&quot;&quot;); Run 一下 Congratulations! 你学会用 NDK 开发了✧｡٩(^㉨^)و✧*｡]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LitePal的基本用法]]></title>
    <url>%2F2017%2F04%2F29%2Flitepal-basic-usage%2F</url>
    <content type="text"><![CDATA[概述LitePal是一个Android开源库，它使开发者使用SQLite数据库变得非常容易。 你可以不用写一句SQL语句就可以完成大部分数据库操作，包括创建表，更新表，约束操作，聚合功能等等。LitePal的安装也相当简单，5分钟之内就可以将它集成到你的工程里。 快速配置 AS添加依赖如下 dependencies &#123; compile 'org.litepal.android:core:1.4.1'&#125; 接着在项目的assets目录下面新建一个litepal.xml文件，并将以下代码拷贝进去： &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="1" &gt;&lt;/version&gt; &lt;list&gt; &lt;/list&gt;&lt;/litepal&gt; 在Application中初始化LitePal public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; super.onCreate(); context = getApplicationContext(); LitePal.initialize(context); &#125; public static Context getContext()&#123; return context; &#125;&#125; 创建和升级数据库 先创建一个tableBean public class Book &#123; private int id; private int pages; private String author; private String name; private double price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getPages() &#123; return pages; &#125; ...&#125; 将Book类添加到模型映射表中 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="1" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.example.admin.turingts.Book"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 然后在进行任意一次数据库操作则数据库会被创建出来 findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Connector.getDatabase(); &#125; &#125;); 如果要升级数据库也无需做备份相关的复杂逻辑，例如增加新表后要升级数据库，如下修改即可 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="2" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.example.admin.turingts.Book"&gt;&lt;/mapping&gt; &lt;mapping class="com.example.admin.turingts.Category"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 添加数据 LitePal要求进行CRUD的模型表必须继承自DataSupport类，所以将Book类进行如下修改 public class Book extends DataSupport&#123; private int id; private int pages; ... 接着我们向Book表中插入数据，如下 findViewById(R.id.btn_add).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; for (int i = 0; i &lt; 10; i++) &#123; Book book = new Book(); book.setAuthor("Keigo"); book.setName("《湖畔》"); book.setPages(10 * i); book.setPrice(99.6); book.setPress("E.T.O"); book.save(); &#125; &#125; &#125;); 更新数据 LitePal提供了updateAll()方法来更新表，操作如下 findViewById(R.id.update).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); book.setAuthor("Keigo"); book.setName("《白夜行》"); book.updateAll("name=? and price=?", "《湖畔》", "99.6"); &#125; &#125;); 可以看到我们先new出了一个Book实例，然后调用对应方法来设置需要更新的数据，最后调用updateAll()来更新表，这里updateAll()我们传入了一个类似于 sqlite 中 where 语句的条件约束来指明我们要更新的是哪条数据，如果这里不增加约束的话，整张表的数据都将被更新。上面的示例表示我要更新 name 字段为 《湖畔》 且 price 字段为 99.6 这条数据的 author 为 Keigo，name 为 《白夜行》。 使用updateAll()还有一点需要注意，就是当你想要更新某个字段的值为默认值时，不能再使用set()。比如更新 pages 为 0，直接调用book.setPages(0)是无效的，因为在 java 中 int 的默认值就是 0 ，所以此时LitePal将不会对此更新，对于要更新的数据，LitePal为我们提供了一个setToDefault()方法，我们传入相应字段名就可以了，如下写法 Book book = new Book();book.setToDefault("pages");book.updateAll(); 上面代码的意思就是，将所有书的页数都更新为 0 ，因为updateAll()方法中没有条件约束，操作对所有数据都生效了。 删除数据 LitePal删除数据的方式有两种，一种直接通过已存储对象的delete()方法删除，另一种方式如下 findViewById(R.id.delete).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //通过delete()删除 Book book = new Book(); if (book.isSaved())&#123; book.delete(); &#125; //通过DataSupport.deleteAll()删除 DataSupport.deleteAll(Book.class, "pages&gt;?", "80"); &#125; &#125;); 这里使用了DataSupport.deleteAll()来删除数据，第一个参数为指定表，第二个参数为约束条件，不指定约束则删除所有数据，同updateAll()原理相似。 查询数据 LitePal查询数据的方式相当人性化，例如查询一张表中的数据，它会自动为我们赋值 findViewById(R.id.query).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;Book&gt; Books = DataSupport.findAll(Book.class); for (Book book : Books) &#123; Log.d(MainActivity.this.TAG,"name:"+book.getName()); Log.d(MainActivity.this.TAG,"pages:"+book.getPages()); Log.d(MainActivity.this.TAG,"author:"+book.getAuthor()); Log.d(MainActivity.this.TAG,"price:"+book.getPrice()); &#125; &#125; &#125;); 除了findAll()之外 LitePal 还提供了其它便捷的 API，例如查询Book表中第一条数据 Book firstBook = DataSupport.findFirst(Book.class); 查询Book表中最后一条数据 Book lastBook = DataSupport.findLast(Book.class); select()方法用于指定查询哪几列数据，例如只获取 name and author 两列数据 List&lt;Book&gt; Books = DataSupport.select("name","author").find(Book.class); where()方法用于指定查询的约束条件，比如查询 author 是 skyrin 的数据 List&lt;Book&gt; Books = DataSupport.where("author=?","skyrin").find(Book.class); order()方法用于对指定结果排序，例如按照 price 升序排列 Book 中的数据 List&lt;Book&gt; Books = DataSupport.order("price ASC").find(Book.class); limit()方法用于指定查询结果的数量，比如只查询表中前3条数据 List&lt;Book&gt; Books = DataSupport.limit(3).find(Book.class); offset()用于指定查询结果的偏移量，比如从第二条开始往后获取3条数据 List&lt;Book&gt; Books = DataSupport.limit(3).offset(1).find(Book.class); 最后你可以使用以上5条规则进行组合，来完成一项复杂查询 List&lt;Book&gt; Books = DataSupport.select("name", "pages") .where("pages&gt;?", "300") .order("pages desc") .limit(10) .offset(5) .find(Book.class); 以上代码表示查询 Book 表中 从 6 ~ 15 条字段为 name 和 pages 且 pages 大于 300 的数据，结果按 pages 降序排列 最后的最后当以上所有方式都无法满足你变态的查询需求时，LitePal 还支持了原生 SQL 语法查询 Cursor c = DataSupport.findBySQL("select * from Book where author=? and pages&gt;?","skyrin","300");]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>LitePal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[youtube-dl CMD]]></title>
    <url>%2F2016%2F12%2F16%2Fyoutube-dl-cmd%2F</url>
    <content type="text"><![CDATA[概述youtube-dl 命令参数简译 USAGE: youtube-dl [OPTIONS] URL [URL…]OPTIONS:通用选项:-h, --help 打印帮助文档 --version 打印版本信息 -U, --update 更新到最新版(需要权限) -i, --ignore-errors 遇到下载错误时跳过 --abort-on-error 遇到下载错误时终止 --dump-user-agent 显示当前使用的浏览器(User-agent) --list-extractors 列出所有的提取器(支持的网站) --extractor-descriptions 同上 --force-generic-extractor 强制使用通用提取器下载 --default-search PREFIX 使用此前缀补充不完整的URLs，例如：&quot;ytsearch2 yt-dl&quot; 从youtube搜索并下载两个关于yt-dl视频. 使用&quot;auto&quot;youtube-dl就会猜一个，一般效果等价于&quot;ytsearch&quot;(&quot;auto_warning&quot;猜测时加入警告).我已知支持的PREFIX：ytsearch (youtube), ytsearchdate (youtube), yvsearch (yahoo videos), gvsearch (google videos) --ignore-config 不读取配置文件，当时用了全局配置文件/etc/youtube-dl.conf:不再读取 ~/.config/youtube-dl/config (%APPDATA%/youtube-dl/config.txt on Windows) --config-location PATH 使用指定路径下的配置文件 --flat-playlist 列出列表视频但不下载 --mark-watched 标记看过此视频 (YouTube only) --no-mark-watched 不标记看过此视频 (YouTube only) --no-color 打印到屏幕上的代码不带色 网络选项:--proxy URL 使用HTTP/HTTPS/SOCKS协议的代理.如：socks5://127.0.0.1:1080/. --socket-timeout SECONDS 放弃连接前等待时间 --source-address IP 绑定的客户端IP地址 -4, --force-ipv4 所有连接通过IPv4 -6, --force-ipv6 所有连接通过IPv6 地理限制:--geo-verification-proxy URL 使用此代理地址测试一些有地理限制的地址 --geo-bypass 绕过地理限制通过伪装X-Forwarded-For HTTP头部的客户端ip (实验) --no-geo-bypass 不 绕过地理限制通过伪装X-Forwarded-For HTTP头部的客户端ip (实验) --geo-bypass-country CODE 强制绕过地理限制通过提供准确的ISO 3166-2标准的国别代码(实验) 注：以上三个实验参数实测未成功 视频选择:--playlist-start NUMBER 指定列表中开始下载的视频(默认为1) --playlist-end NUMBER 指定列表中结束的视频(默认为last) --playlist-items ITEM_SPEC 指定列表中要下载的视频项目编号.如：&quot;--playlist-items 1,2,5,8&quot;或&quot;--playlist-items 1-3,7,10-13&quot; --match-title REGEX 下载标题匹配的视频(正则表达式或区分大小写的字符串) --reject-title REGEX 跳过下载标题匹配的视频(正则表达式或区分大小写的字符串) --max-downloads NUMBER 下载NUMBER个视频后停止 --min-filesize SIZE 不下载小于SIZE的视频(e.g. 50k or 44.6m) --max-filesize SIZE 不下载大于SIZE的视频(e.g. 50k or 44.6m) --date DATE 仅下载上传日期在指定日期的视频 --datebefore DATE 仅下载上传日期在指定日期或之前的视频 (i.e. inclusive) --dateafter DATE 仅下载上传日期在指定日期或之后的视频 (i.e. inclusive) --min-views COUNT 不下载观影数小于指定值的视频 --max-views COUNT 不下载观影数大于指定值的视频 --match-filter FILTER 通用视频过滤器. Specify any key (see help for -o for a list of available keys) to match if the key is present, !key to check if the key is not present, key &gt; NUMBER (like &quot;comment_count &gt; 12&quot;, also works with &gt;=, &lt;, &lt;=, !=, =) to compare against a number,key = ‘LITERAL‘ (like &quot;uploader = ‘Mike Smith‘&quot;, also works with !=) to match against a string literal and &amp; to require multiple matches. Values which are not known are excluded unless you put a question mark (?) after the operator. For example, to only match videos that have been liked more than 100 times and disliked less than 50 times (or the dislike functionality is not available at the given service), but who also have a description, use --match-filter &quot;like_count &gt; 100 &amp; dislike_count &lt;? 50 &amp; description&quot; . --no-playlist 当视频链接到一个视频和一个播放列表时，仅下载视频 --yes-playlist 当视频链接到一个视频和一个播放列表时，下载视频和播放列表 --age-limit YEARS 下载合适上传年限的视频 --download-archive FILE 仅下载档案文件中未列出的影片，已下载的记录ID --include-ads 同时下载广告(实验) 下载选项:-r, --limit-rate RATE 最大bps (e.g. 50K or 4.2M) -R, --retries RETRIES 重试次数 (默认10), or &quot;infinite&quot;. --fragment-retries RETRIES 一个分段的最大重试次数(default is 10), or &quot;infinite&quot; (DASH, hlsnative and ISM) --skip-unavailable-fragments 跳过不可用分段(DASH, hlsnative and ISM) --abort-on-unavailable-fragment 放弃某个分段当不可获取时 --keep-fragments 下载完成后，将下载的片段保存在磁盘上; 片段默认被删除 --buffer-size SIZE 设置缓冲区大小buffer (e.g. 1024 or 16K) (default is 1024) --no-resize-buffer 不自动调整缓冲区大小.默认情况下自动调整 --playlist-reverse 以相反的顺序下载播放列表视频 --playlist-random 以随机的顺序下载播放列表视频 --xattr-set-filesize Set file xattribute ytdl.filesize with expected file size (experimental) --hls-prefer-native 使用本机默认HLS下载器而不是ffmpeg --hls-prefer-ffmpeg 使用ffmpeg而不是本机HLS下载器 --hls-use-mpegts 使用TS流容器来存放HLS视频,一些高级播放器允许在下载的同时播放视频 --external-downloader COMMAND 使用指定的第三方下载工具,当前支持：aria2c,avconv,axel,curl,ffmpeg,httpie,wget --external-downloader-args ARGS 给第三方下载工具指定参数，如：--external-downloader aria2c --external-downloader-args -j8 文件系统选项:-a, --batch-file FILE 文件中包含需要下载的URL --id 仅使用文件名中的视频ID -o, --output TEMPLATE Output filename template, see the &quot;OUTPUT TEMPLATE&quot; for all the info --autonumber-start NUMBER 指定%(autonumber)s的起始值(默认为1) --restrict-filenames 将文件名限制为ASCII字符，并避免文件名中的“＆”和空格 -w, --no-overwrites 不要覆盖文件 -c, --continue 强制恢复部分下载的文件。 默认情况下，youtube-dl仅在可能时将恢复下载。 --no-continue 不要恢复部分下载的文件(从头开始重新启动) --no-part 不使用.part文件 - 直接写入输出文件 --no-mtime 不使用Last-modified header来设置文件最后修改时间 --write-description 将视频描述写入.description文件 --write-info-json 将视频元数据写入.info.json文件 --write-annotations 将视频注释写入.annotations.xml文件 --load-info-json FILE 包含视频信息的JSON文件(使用“--write-info-json”选项创建) --cookies FILE 文件从中读取Cookie(经测试，export cookies插件可以使用，但firebug导出的cookies导致错误,chrome下请用cookies.txt)注意：不同平台windows、Linux、OSX之间需要转换CE LF才能使用！ --cache-dir DIR 文件存储位置。youtube-dl需要永久保存一些下载的信息。默认为$XDG_CACHE_HOME/youtube-dl或/.cache/youtube-dl。目前，只有YouTube播放器文件（对于具有模糊签名的视频）进行缓存，但可能会发生变化。 --no-cache-dir 不用缓存 --rm-cache-dir 删除所有缓存文件 缩略图:--write-thumbnail 把缩略图写入硬盘 --write-all-thumbnails 将所有缩略图写入磁盘 --list-thumbnails 列出所有可用的缩略图格式 详细/模拟选项:-q, --quiet 激活退出模式 --no-warnings 忽略警告 -s, --simulate 不下载不存储任何文件到硬盘，模拟下载模式 --skip-download 不下载视频 -g, --get-url 模拟下载获取视频直连 -e, --get-title 模拟下载获取标题 --get-id 模拟下载获取id --get-thumbnail 模拟下载获取缩略图URL --get-description 模拟下载获取视频描述 --get-duration 模拟下载获取视频长度 --get-filename 模拟下载获取输出视频文件名 --get-format 模拟下载获取输出视频格式 -j, --dump-json 模拟下载获取JSON information. -J, --dump-single-json 模拟下载获取每条命令行参数的JSON information.如果是个播放列表，就获取整个播放列表的JSON --print-json 下载的同时获取视频信息的JSON --newline 进度条在新行输出 --no-progress 不打印进度条 --console-title 在控制台标题栏显示进度 -v, --verbose 打印各种调试信息 --dump-pages 打印下载下来的使用base64编码的页面来调试问题（非常冗长） --write-pages 将下载的中间页以文件的形式写入当前目录中以调试问题 --print-traffic 显示发送和读取HTTP流量 -C, --call-home 联系youtube-dl服务器进行调试 --no-call-home 不联系youtube-dl服务器进行调试 解决方法:--encoding ENCODING 强制指定编码(实验) --no-check-certificate 禁止HTTPS证书验证 --prefer-insecure 使用未加密的连接来检索有关视频的信息(目前仅支持YouTube) --user-agent UA 指定user agent --referer URL 指定自定义的referer,仅限视频来源于同一网站 --add-header FIELD:VALUE 指定一个自定义值的HTTP头文件,使用分号分割,可以多次使用此选项 --bidi-workaround 围绕缺少双向文本支持的终端工作。需要在PATH中有bidiv或fribidi可执行文件 --sleep-interval SECONDS 在每次下载之前休眠的秒数，或者每次下载之前的随机睡眠的范围的下限(最小可能的睡眠秒数)与-max-sleep-interval一起使用。 --max-sleep-interval SECONDS 每次下载前随机睡眠范围的上限(最大可能睡眠秒数)。只能与--min-sleep-interval一起使用。 视频格式选项:-f, --format FORMAT 视频格式代码,查看&quot;FORMAT SELECTION&quot;获取所有信息 --all-formats 获取所有视频格式 --prefer-free-formats 开源的视频格式优先，除非有特定的请求 -F, --list-formats 列出请求视频的所有可用格式 --youtube-skip-dash-manifest 不要下载关于YouTube视频的DASH清单和相关数据 --merge-output-format FORMAT 如果需要合并(例如bestvideo + bestaudio)，则输出到给定的容器格式。mkv，mp4，ogg，webm，flv之一。如果不需要合并，则忽略 字幕选项:--write-sub 下载字幕文件 --write-auto-sub 下载自动生成的字幕文件 (YouTube only) --all-subs 下载所有可用的字幕 --list-subs 列出所有字幕 --sub-format FORMAT 字幕格式,接受格式偏好,如：&quot;srt&quot; or &quot;ass/srt/best&quot; --sub-lang LANGS 要下载的字幕的语言(可选)用逗号分隔,请使用--list-subs表示可用的语言标签 验证选项:-u, --username USERNAME 使用ID登录 -p, --password PASSWORD 账户密码,如果此选项未使用,youtube-dl将交互式地询问。 -2, --twofactor TWOFACTOR 双因素认证码 -n, --netrc 使用.netrc认证数据 --video-password PASSWORD 视频密码(vimeo, smotri, youku) Adobe Pass 选项:--ap-mso MSO Adobe Pass多系统运营商(电视提供商)标识符,使用--ap-list-mso列出可用的MSO --ap-username USERNAME MSO账号登录 --ap-password PASSWORD 账户密码,如果此选项未使用,youtube-dl将交互式地询问。 --ap-list-mso 列出所有支持的MSO 后处理选项:-x, --extract-audio 将视频文件转换为纯音频文件(需要ffmpeg或avconv和ffprobe或avprobe) --audio-format FORMAT 指定音频格式: &quot;best&quot;, &quot;aac&quot;, &quot;flac&quot;, &quot;mp3&quot;, &quot;m4a&quot;, &quot;opus&quot;, &quot;vorbis&quot;, or &quot;wav&quot;; &quot;best&quot; by default;-x存在时无效 --audio-quality QUALITY 指定ffmpeg/avconv音频质量,为VBR插入一个0(best)-9(worse)的值(默认5),或者指定比特率 --recode-video FORMAT 必要时将视频转码为其他格式(当前支持: mp4|flv|ogg|webm|mkv|avi) --postprocessor-args ARGS 给后处理器提供这些参数 -k, --keep-video 视频文件在后处理后保存在磁盘上; 该视频默认被删除 --no-post-overwrites 不要覆盖后处理文件; 默认情况下,后处理文件将被覆盖 --embed-subs 在视频中嵌入字幕(仅适用于mp4,webm和mkv视频） --embed-thumbnail 将缩略图嵌入音频作为封面艺术 --add-metadata 将元数据写入视频文件 --metadata-from-title FORMAT 从视频标题中解析附加元数据，如歌曲标题/艺术家。格式语法和--output相似.也可以使用带有命名捕获组的正则表达式。解析的参数替换现有值。Example: --metadata-from-title &quot;%(artist)s - %(title)s&quot; matches a title like &quot;Coldplay - Paradise&quot;. Example (regex): --metadata-from-title &quot;(?P&lt;artist&gt;.+?) - (?P&lt;title&gt;.+)&quot; --xattrs 将元数据写入视频文件的xattrs(使用dublin core 和 xdg标准) --fixup POLICY 自动更正文件的已知故障。never(不做警告), warn(只发出警告), detect_or_warn (默认;如果可以的话修复文件,否则警告) --prefer-avconv 后处理时相较ffmpeg偏向于avconv --prefer-ffmpeg 后处理优先使用ffmpeg --ffmpeg-location PATH ffmpeg/avconv程序位置;PATH为二进制所在文件夹或者目录. --exec CMD 在下载后对文件执行命令,类似于find -exec语法.示例：--exec‘adb push {} /sdcard/Music/ &amp;&amp; rm {}‘ --convert-subs FORMAT 转换字幕格式(当前支持: srt|ass|vtt) 输出模板该-o选项允许用户指定输出文件名称的模板。 基本用法下载一个文件时，就像在没有设置任何模板参数youtube-dl -o funny_video.flv “https://some/video&quot;。但是，它可能包含下载每个视频时将被替换的特殊序列。特殊序列可以根据python字符串格式化操作来格式化。例如，%(NAME)s或者%(NAME)05d。为了澄清，这是一个百分号，后面跟着一个名字，然后是格式化操作。允许的名称和序列类型是： id （字符串）： 视频标识符 title （字符串）： 视频标题 url （字符串）： 视频网址 ext （字符串）： 视频文件扩展名 alt_title （字符串）： 视频的次要标题 display_id （字符串）： 视频的替代标识符 uploader （字符串）： 视频上传器的全名 license （字符串）： 视频许可的许可证名称 creator （字符串）： 视频的创建者 release_date （字符串）： 视频发布时的日期（YYYYMMDD） timestamp （数字）： 视频可用时的UNIX时间戳 upload_date （字符串）： 视频上传日期（YYYYMMDD） uploader_id （字符串）： 视频上传器的昵称或ID location （字符串）： 视频被拍摄的物理位置 duration （数字）： 以秒为单位的视频长度 view_count （数字）： 有多少用户在该平台上观看过视频 like_count （数字）： 视频的正面评级的数量 dislike_count （数字）： 视频的负面评级的数量 repost_count （数字）： 视频的转贴次数 average_rating （数字）： 用户给出的平均评分，使用的比例取决于网页 comment_count （数字）： 视频上的评论数量 age_limit （数字）： 视频年龄限制（年） is_live （布尔值）： 这个视频是一个实时流还是一个固定长度的视频 start_time （数字）： 按照URL中的指定开始复制的时间（以秒为单位） end_time （数字）： 按照URL中的指定，结束复制的时间（以秒为单位） format （字符串）： 格式的可读描述 format_id （字符串）： 指定的格式代码 --format format_note （字符串）： 关于格式的附加信息 width （数字）： 视频的宽度 height （数字）： 视频的高度 resolution （字符串）： 宽度和高度的文本描述 tbr （数字）： 音频和视频的平均比特率，以KBit / s为单位 abr （数字）： 以KBit / s为单位的平均音频比特率 acodec （字符串）： 正在使用的音频编解码器的名称 asr （数字）： 以赫兹为单位的音频采样率 vbr （数字）： 以KBit / s为单位的平均视频比特率 fps （数字）： 帧率 vcodec （字符串）： 正在使用的视频编解码器的名称 container （字符串）： 容器格式的名称 filesize （数字）： 如果预先知道的话，字节数 filesize_approx（数字）： 字节数的估计值 protocol （字符串）： 将用于实际下载的协议 extractor （字符串）： 提取器的名称 extractor_key （字符串）： 提取器的键名 epoch （数字）： 创建文件时的Unix纪元 autonumber （数字）： 从零开始，每次下载将增加的五位数字 playlist （字符串）： 包含视频的播放列表的名称或ID playlist_index （数字）： 根据播放列表的总长度填充前导零的播放列表中的视频索引 playlist_id （字符串）： 播放列表标识符 playlist_title （字符串）： 播放列表标题 playlist_uploader （字符串）： 播放列表上传者的全名 playlist_uploader_id （字符串）： 播放列表上传者的昵称或ID 可用于属于某个逻辑章节或部分的视频： chapter （字符串）： 视频所属章节的名称或标题 chapter_number （数字）： 视频所属章节的编号 chapter_id （字符串）： 视频所属章节的ID 可用于某个系列或节目的情节的视频： series （字符串）： 该视频片段所属的系列或节目的标题 season （字符串）： 视频剧集所属季节的标题 season_number （数字）： 视频片段属于的季节的数量 season_id （字符串）： 视频片段属于的季节的ID episode （字符串）： 视频片段的标题 episode_number （数字）： 一个季节内的视频片段的数量 episode_id （字符串）： 视频情节的ID 适用于音乐专辑的音轨或音乐专辑的媒体： track （字符串）： 曲目的标题 track_number （数字）： 专辑或光盘中的曲目编号 track_id （字符串）： 轨道的Id artist （字符串）： 曲目的艺术家 genre （字符串）： 曲目的类型 album （字符串）： 曲目所属专辑的标题 album_type （字符串）： 相册的类型 album_artist （字符串）： 专辑中出现的所有艺术家列表 disc_number （数字）： 轨道所属的光盘或其他物理介质的编号 release_year （数字）： 发行专辑时的年（YYYY） 在输出模板中引用的每个上述序列都将被与序列名称对应的实际值替换。请注意，某些序列不能保证存在，因为它们依赖于特定提取器获得的元数据。这样的序列将被替换为NA。 例如，对于-o %(title)s-%(id)s.%(ext)s带有标题youtube-dl test video和ID 的mp4视频BaW_jenozKcj，这将导致在youtube-dl test video-BaW_jenozKcj.mp4当前目录中创建一个文件。对于数字序列，您可以使用与数字相关的格式，例如，%(view_count)05d将导致视图计数的字符串填充最多5个字符的零，如in 00042。 输出模板还可以包含任意的分层路径，例如-o ‘%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s’，这将导致下载与该路径模板相对应的目录中的每个视频。任何丢失的目录将自动为您创建。要在输出模板使用使用％的文字%%。输出到标准输出使用-o -。当前的默认模板是%(title)s-%(id)s.%(ext)s。 在某些情况下，您不需要特殊字符（如中，空格或＆），例如通过8位不安全通道将下载的文件名传送到Windows系统或文件名时。在这些情况下，添加–restrict-filenames标志以获得较短的标题：输出模板和Windows批处理文件 如果您在Windows批处理文件中使用输出模板，那么您必须%通过加倍来避免普通的百分号字符（），所以-o “%(title)s-%(id)s.%(ext)s”应该成为-o “%%(title)s-%%(id)s.%%(ext)s”。但是你不应该碰到%不是普通字符的东西，例如扩展的环境变量应该保持不变-o “C:\%HOMEPATH%\Desktop\%%(title)s.%%(ext)s”。]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
